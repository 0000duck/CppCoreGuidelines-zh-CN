# <a name="main"></a>C++ 核心指南

2016/2/15

编辑：

* [Bjarne Stroustrup](http://www.stroustrup.com)
* [Herb Sutter](http://herbsutter.com/)

翻译：

* 李一楠 (li_yinan AT 163 DOT com)

本文档是早期草稿。本文档有错漏，格式也不正规。
本文档作为开源项目，发布版本为 0.6。
复制，使用，修改，以及创建本项目的衍生物，受到一份 MIT 风格的版权授权。
向本项目作出贡献需要同意一份贡献者授权。详情参见附属的 [LICENSE](LICENSE) 文件。
我们将本项目开放给“友好用户”进行使用，复制，修改，以及生产衍生物，并希望能够获得建设性的资源投入。

十分欢迎大家提出意见和改进建议。
随着我们的知识增长，随着语言和可用的程序库的改进，我们计划对这份文档不断进行修改和扩充。
当提出您的意见时，请关注[导言](#S-introduction)部分，其中概述了我们的目标和所采用的一般方法。
贡献者的列表请参见[这里](#SS-ack)。

已知问题：

* 仍未对规则集合的完整性、一致性和可强制实施性加以检查。
* 三问号 (???) 用于标记已知的信息缺失。
* 需要更新参考部分；许多前 C++11 的源代码都过于老旧。
* [To-do: 未分类的规则原型](#S-unclassified) 是一份基本上保持最新状态的 to-do 列表。

您可以[阅读本指南的范围和结构的说明](#S-abstract)，或者直接跳转到：

* [In: 导言](#S-introduction)
* [P: 指导思想](#S-philosophy)
* [I: 接口](#S-interfaces)
* [F: 函数](#S-functions)
* [C: 类和类层次](#S-class)
* [Enum: 枚举](#S-enum)
* [R: 资源管理](#S-resource)
* [ES: 表达式和语句](#S-expr)
* [E: 错误处理](#S-errors)
* [Con: 常量和不可变性](#S-const)
* [T: 模板和泛型编程](#S-templates)
* [CP: 并发](#S-concurrency)
* [SL: 标准库](#S-stdlib)
* [SF: 源文件](#S-source)
* [CPL: C 风格的编程](#S-cpl)
* [PRO: 剖面配置](#S-profile)
* [GSL: 指南支持库](#S-gsl)
* [FAQ: 常见问题的解答](#S-faq)

配套章节：

* [NL: 命名和代码布局](#S-naming)
* [PER: 性能](#S-performance)
* [N: 伪规则和错误的看法](#S-not)
* [RF: 参考](#S-references)
* [附录 A: 程序库](#S-libraries)
* [附录 B: 代码的现代化](#S-modernizing)
* [附录 C: 相关讨论](#S-discussion)
* [词汇表](#S-glossary)
* [To-do: 未分类的规则原型](#S-unclassified)

也可以查看具体的语言特性

* [赋值](#S-???)
* [`class`](#S-class)
* [构造函数](#SS-ctor)
* [派生 `class`](#SS-hier)
* [析构函数](#SS-dtor)
* [异常](#S-errors)
* [`for`](#S-???)
* [`inline`](#S-class)
* [初始化](#S-???)
* [lambda 表达式](#SS-lambdas)
* [运算符](#S-???)
* [`public`, `private`, 和 `protected`](#S-???)
* [`static_assert`](#S-???)
* [`struct`](#S-class)
* [`template`](#S-???)
* [`unsigned`](#S-???)
* [`virtual`](#SS-hier)

还有一些用于表达和讨论的术语的定义，它们不属于语言技术，而是有关设计和编程技术的术语。

* 错误（Error）
* 异常（Exception）
* 故障（Failure）
* 不变式（Invariant）
* 泄漏（Leak）
* 前条件（Precondition）
* 后条件（Postcondition）
* 资源（Resource）
* 异常保证（Exception Guarantee）

# <a name="S-abstract"></a>概要

本文档是一组有关如何更好使用 C++ 的指南。
本文档的目标是帮助人们更有效地使用现代 C++。
所谓“现代”的含义是指 C++11 和 C++14（以及即将到来的 C++17）。
换句话说，如果你从现在开始算起，五年后你的代码看起来是怎么样的？十年呢？

指南所关注的是一些相对比较高层次的问题，比如接口，资源管理，内存管理，以及并发等等。
这样的规则会对应用的架构，以及程序库的设计都造成影响。
如果遵循这些规则，代码将会是静态类型安全的，没有资源泄露，并且能够捕捉到比当今的代码通常所能捕捉到的多得多的编程逻辑错误。
还能更快速地运行——你不必牺牲程序的正确性。

我们对于如命名约定和缩进风格一类的低层次的问题不那么关注。
当然，对程序员有帮助的任何话题都是可接受的。

我们最初的规则集合强调的是（各种形式的）安全性以及简单性。
它们有些过于严格了。
我们预期将会引入更多的例外情况， 以便使它们更好地适应现实世界的需要。
我们也需要更多的规则。

您可能会发现，有的规则与您的预期相反，甚至是与您的经验相违背。
其实如果我们没建议您在任何方面改变您的编码风格，那其实就是我们的失败！
请您尝试验证或者证伪这些规则吧！
尤其是，我们十分期望让一些规则能够建立在真实的测量数据上，或者是一些更好的例子之上。

您可能会觉得一些规则很显然，甚至没有什么价值。
但请记住，一份指南的目的之一就在于帮助那些经验不足的，或来自其他背景或使用其他语言的人，能够迅速行动起来。

指南中的许多规则有意设计成可以由分析工具提供支持的。
违反规则的代码会打上标记，以引用（或者链接）到相关的规则。
您在开始编码前并不需要记住所有这些规则。
一种看待这些指南的方式，是一份恰好可以让人类读懂的针对这些工具的规范文件。

这些规则都是为了逐步引入一个代码库而设计的。
我们计划建立这样的工具，并希望其他人也能提供它们。

十分欢迎大家提出意见和改进建议。
随着我们的知识增长，随着语言和可用的程序库的改进，我们计划对这份文档不断进行修改和扩充。

# <a name="S-introduction"></a>In: 导言

本文档是一组核心指南，针对现代 C++（C++14），还考虑到了语言将来有希望的增强，以及 ISO 技术规范（TSs）。
其目标是帮助 C++ 程序员编写更简单、更高效、更加可维护的代码。

导言概览：

* [In.target: 目标读者](#SS-readers)
* [In.aims: 目标](#SS-aims)
* [In.not: 非目标](#SS-non)
* [In.force: 强制实施](#SS-force)
* [In.struct: 本文档的结构](#SS-struct)
* [In.sec: 主要章节](#SS-sec)

## <a name="SS-readers"></a>In.target: 目标读者

所有 C++ 程序员。其中也包括[考虑采用 C 语言的程序员](#S-cpl)。

## <a name="SS-aims"></a>In.aims: 目标

本文档的目标是帮助开发者采用现代 C++（C++11，C++14，以及不久后的 C++17），并在各个代码基之间达成更加统一的编码风格。

我们并不妄想这些规则中的每一条都能有效地在任何代码基中进行实施。对老旧系统进行升级是很困难的。不过我们确实认为，采纳了一条规则的程序总会比不这样做的程序更加不易出错也更加便于维护。通常，采用规则也会带来更快速或更容易的初始开发活动。
就我们所能说的，这些规则能够使得代码的性能，相对于更传统的技术来说同样好甚至更好；它们都是依照零开销原则设立的——“不使用就没有负担”（"what you don't use, you don't pay for"）或“当恰当地使用抽象机制时，所得的性能至少与使用低级语言构造手工编码的结果一样好”。
我们认为这些规则对新代码来说是理想的，也有很多机会在老代码中实施，并使这两者尽可能接近。
请记住：

