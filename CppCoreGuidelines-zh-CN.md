# <a name="main"></a>C++ 核心指导方针

2016/2/15

编辑：

* [Bjarne Stroustrup](http://www.stroustrup.com)
* [Herb Sutter](http://herbsutter.com/)

翻译：

* 李一楠 (li_yinan AT 163 DOT com)

本文档是早期草稿。本文档有错漏，格式也不正规。
本文档作为开源项目，发布版本为 0.6。
复制，使用，修改，以及创建本项目的衍生物，受到一份 MIT 风格的版权授权。
向本项目作出贡献需要同意一份贡献者授权。详情参见附属的 [LICENSE](LICENSE) 文件。
我们将本项目开放给“友好用户”进行使用，复制，修改，以及生产衍生物，并希望能够获得建设性的资源投入。

十分欢迎大家提出意见和改进建议。
随着我们的知识增长，随着语言和可用的程序库的改进，我们计划对这份文档不断进行修改和扩充。
当提出您的意见时，请关注[导言](#S-introduction)部分，其中概述了我们的目标和所采用的一般方法。
贡献者的列表请参见[这里](#SS-ack)。

已知问题：

* 仍未对规则集合的完整性、一致性和可强制实施性加以检查。
* 三问号 (???) 用于标记已知的信息缺失。
* 需要更新参考部分；许多前 C++11 的源代码都过于老旧。
* [To-do: 未分类的规则原型](#S-unclassified) 是一份基本上保持最新状态的 to-do 列表。

您可以[阅读本指南的范围和结构的说明](#S-abstract)，或者直接跳转到：

* [In: 导言](#S-introduction)
* [P: 理念](#S-philosophy)
* [I: 接口](#S-interfaces)
* [F: 函数](#S-functions)
* [C: 类和类层次](#S-class)
* [Enum: 枚举](#S-enum)
* [R: 资源管理](#S-resource)
* [ES: 表达式和语句](#S-expr)
* [E: 错误处理](#S-errors)
* [Con: 常量和不可变性](#S-const)
* [T: 模板和泛型编程](#S-templates)
* [CP: 并发](#S-concurrency)
* [SL: 标准库](#S-stdlib)
* [SF: 源文件](#S-source)
* [CPL: C 风格的编程](#S-cpl)
* [PRO: 剖面配置](#S-profile)
* [GSL: 指导方针支持库](#S-gsl)
* [FAQ: 常见问题的解答](#S-faq)

配套章节：

* [NL: 命名和代码布局](#S-naming)
* [PER: 性能](#S-performance)
* [N: 伪规则和错误的看法](#S-not)
* [RF: 参考资料](#S-references)
* [附录 A: 程序库](#S-libraries)
* [附录 B: 代码的现代化](#S-modernizing)
* [附录 C: 相关讨论](#S-discussion)
* [词汇表](#S-glossary)
* [To-do: 未分类的规则原型](#S-unclassified)

也可以查看具体的语言特性

* [赋值](#S-???)
* [`class`](#S-class)
* [构造函数](#SS-ctor)
* [派生 `class`](#SS-hier)
* [析构函数](#SS-dtor)
* [异常](#S-errors)
* [`for`](#S-???)
* [`inline`](#S-class)
* [初始化](#S-???)
* [lambda 表达式](#SS-lambdas)
* [运算符](#S-???)
* [`public`, `private`, 和 `protected`](#S-???)
* [`static_assert`](#S-???)
* [`struct`](#S-class)
* [`template`](#S-???)
* [`unsigned`](#S-???)
* [`virtual`](#SS-hier)

还有一些用于表达和讨论的术语的定义，它们不属于语言技术，而是有关设计和编程技术的术语。

* 错误（Error）
* 异常（Exception）
* 故障（Failure）
* 不变式（Invariant）
* 泄漏（Leak）
* 前条件（Precondition）
* 后条件（Postcondition）
* 资源（Resource）
* 异常保证（Exception Guarantee）

# <a name="S-abstract"></a>概要

本文档是一组有关如何更好使用 C++ 的指导方针的集合。
本文档的目标是帮助人们更有效地使用现代 C++。
所谓“现代”的含义是指 C++11 和 C++14（以及即将到来的 C++17）。
换句话说，如果你从现在开始算起，五年后你的代码看起来是怎么样的？十年呢？

这些指导方针所关注的是一些相对比较高层次的问题，比如接口，资源管理，内存管理，以及并发等等。
这样的规则会对应用的架构，以及程序库的设计都造成影响。
如果遵循这些规则，代码将会是静态类型安全的，没有资源泄露，并且能够捕捉到比当今的代码通常所能捕捉到的多得多的编程逻辑错误。
还能更快速地运行——你不必牺牲程序的正确性。

我们对于如命名约定和缩进风格一类的低层次的问题不那么关注。
当然，对程序员有帮助的任何话题都是可接受的。

我们最初的规则集合强调的是（各种形式的）安全性以及简单性。
它们有些过于严格了。
我们预期将会引入更多的例外情况， 以便使它们更好地适应现实世界的需要。
我们也需要更多的规则。

您可能会发现，有的规则与您的预期相反，甚至是与您的经验相违背。
其实如果我们没建议您在任何方面改变您的编码风格，那其实就是我们的失败！
请您尝试验证或者证伪这些规则吧！
尤其是，我们十分期望让一些规则能够建立在真实的测量数据上，或者是一些更好的例子之上。

您可能会觉得一些规则很显然，甚至没有什么价值。
但请记住，指导方针的目的之一就在于帮助那些经验不足的，或来自其他背景或使用其他语言的人，能够迅速行动起来。

这里的许多规则有意设计成可以由分析工具提供支持的。
违反规则的代码会打上标记，以引用（或者链接）到相关的规则。
您在开始编码前并不需要记住所有这些规则。
一种看待这些指导方针的方式，是一份恰好可以让人类读懂的针对这些工具的规范文件。

这些规则都是为了逐步引入一个代码库而设计的。
我们计划建立这样的工具，并希望其他人也能提供它们。

十分欢迎大家提出意见和改进建议。
随着我们的知识增长，随着语言和可用的程序库的改进，我们计划对这份文档不断进行修改和扩充。

# <a name="S-introduction"></a>In: 导言

本文档是一组核心指导方针，针对现代 C++（C++14），还考虑到了语言将来有希望的增强，以及 ISO 技术规范（TSs）。
其目标是帮助 C++ 程序员编写更简单、更高效、更加可维护的代码。

导言概览：

* [In.target: 目标读者](#SS-readers)
* [In.aims: 目标](#SS-aims)
* [In.not: 非目标](#SS-non)
* [In.force: 强制实施](#SS-force)
* [In.struct: 本文档的结构](#SS-struct)
* [In.sec: 主要章节](#SS-sec)

## <a name="SS-readers"></a>In.target: 目标读者

所有 C++ 程序员。其中也包括[考虑采用 C 语言的程序员](#S-cpl)。

## <a name="SS-aims"></a>In.aims: 目标

本文档的目标是帮助开发者采用现代 C++（C++11，C++14，以及不久后的 C++17），并在各个代码库之间达成更加统一的编码风格。

我们并不妄想这些规则中的每一条都能有效地在任何代码库中进行实施。对老旧系统进行升级是很困难的。不过我们确实认为，采纳了一条规则的程序总会比不这样做的程序更加不易出错也更加便于维护。通常，采用规则也会带来更快速或更容易的初始开发活动。
就我们所能说的，这些规则能够使得代码的性能，相对于更传统的技术来说同样好甚至更好；它们都是依照零开销原则设立的——“不使用就没有负担”（"what you don't use, you don't pay for"）或“当恰当地使用抽象机制时，所得的性能至少与使用低级语言构造手工编码的结果一样好”。
我们认为这些规则对新代码来说是理想的，也有很多机会在老代码中实施，并使这两者尽可能接近。
请记住：

### <a name="R0"></a>In.0: 不要慌张！

请花些时间理解一下指南规则对你的程序能够造成的影像。

这些指导方针都是遵循“超集的子集”原则（[Stroustrup05](#Stroustrup05)）而设计的。
它们并非仅仅定义了 C++ 的一个可以使用的子集（以获得比如说可靠性，安全性，性能，或者别的什么）。
它们强烈地推崇使用一些简单的“扩展”（[程序库组件](#S-gsl)），
使得最易出错的 C++ 特性变得不再必须，并且可以（通过这些规则）禁止再使用它们。

这些规则都强调静态类型安全性和资源安全性。
鉴于此，它们强调了进行范围检查，避免对 `nullptr` 解引用，避免悬挂指针，以及（通过 RAII）系统性地使用异常的可能性。
部分地为达成这点，也部分地为了最小化会带来错误的晦涩难懂的代码，这些规则同样强调了简单性，以及将必须的复杂性隐藏于经过充分说明的接口后面。

有许多规则都是约定性质的。
我们认为，那些单纯说“禁止这样！”而又不提供替代方案的规则是不可取的。
但这样的后果就是让一些规则只能以启发式方法，而不是精确地和机械化地进行验证检查。
还有一些规则所表达的是一些一般性的原则。对于这些一般性规则，我们会提供一些更精细和更特定的规则来进行不完全的检查。

这些指导方针所关注的是 C++ 的核心部分及其使用方式。
我们认为大多数的大型团体，特定的应用领域，甚至一些大型项目都会需要更多的规则，也许是更多的限制规则，或是更多的库支持。
例如说，硬实时开发人员通常都无法随意使用自由存储（动态内存），并且在选择程序库上也有许多限制。
我们鼓励各方开发这样的专门规则，以作为我们的核心指导方针的补充。
请构建你自己的基础程序库并使用它，而不要把你的开发层次降低到汇编代码之中。

这些规则的设计使其能够进行[渐进式的采纳](#S-modernizing)。

一些规则的目标是提升各种形式的安全性，而另外一些的目标是减少意外的发生，还有许多则同时兼顾。
目标是避免意外事故的指导方针通常会禁止完全合法的 C++ 用法。
不管怎样，每当存在两种达成效果的方式，其中一种被证实是常见的错误来源，而另外一种并非如此时，我们都会努力引导程序员采纳后者。

## <a name="SS-non"></a>In.not: 非目标

我们没打算让这些规则保持精简或正交。
特别地说，一般性规则可以很简单，但却没办法强制实施。
而且要搞清楚一条一般性规则所造成的影响通常是很困难的。
通常更专门的规则都更易于理解清楚，也更易于实施，但如果没有那些一般性规则的话，它们不过是一大堆特殊情况而已。
我们既要提供能够帮到新手的规则，也要提供能够支持专家使用的规则。
其中的一些规则是完全可以强制实行的，而另外的一些则是基于启发式方案的规则。

并不需要像读书一样从头到尾地阅读这些规则。
您可以利用链接来进行浏览。
不过，这些规则的主要预期用途是作为工具的检查目标。
就是说，由工具来查找规则的违反情况，然后工具会返回指向所违反的规则的链接。
而规则之中则提供了其理由，违反规则的潜在后果的例子，以及一些改正建议。

这些指导方针并不是用来替代 C++ 的教程材料的。
如果您需要针对某个经验水平的教程，请参见[参考资料](#S-references)。

本文档并不是一份如何把老旧 C++ 代码转化为更加现代的代码的指南。
而是旨在以一种具体化的方式来阐明对于新代码的设想。
当然，对于进行代码现代化，使其恢复活力或者升级的可行方式，可以参考[代码现代化章节](#S-modernizing)。
重要的是，这些规则是允许渐进式采纳的：对大型代码库进行一次性全部转化通常都是不可行的。

这些指导方针并不会对于语言技术的每个细节上都保持完整和精确。
如果需要，请参考 C++ 标准，关于语言定义上的最终文本，其中包括一般性规则的每种例外情况，也包括所有特性。

这些规则不是为了强迫你使用 C++ 的某个阉割子集来编写代码的。
它们*尤其着重*避免去定义一种像（比如）Java 一样的 C++ 子集。
它们也避免去定义一个单一的所谓“真正的 C++”的语言。
我们重视语言的表达能力和不打折扣的性能。

这些规则并不是价值观中立的。
它们旨在使代码变得相对于现有大多数 C++ 代码来说更简单，并且更加正确和安全，又不会有任何性能损失。
它们旨在约束对那些完全合法的，但却与错误、虚假的复杂性以及不良性能有关的 C++ 代码的使用。

## <a name="SS-force"></a>In.force: 强制实施

无法强制实施的规则对于大型代码库来说是难以操作的。
所有规则都强制实施，则仅对于一个小的规则集合，或者对于某些特定用户群来说是可行的。
但我们需要大量的规则，需要每个人都能使用的规则。
不同的人的要求都不一样。
人们不想阅读大量的规则。
人们也无法记住太多规则。
因此，我们需要建立规则子集以满足各种不同的需要。
但任意性地建立子集也会导致混乱：我们想要的是可以帮助到许多人的指导方针，使代码更加统一，并有力地促进人们将他们的代码现代化。
我们想要促进最佳实践，而不是让人们陷入大量选项之中而增加管理压力。
理想情况是使用全部规则；这会带来极大的好处。

但这样也带来了一些困难之处。
我们试图通过使用工具来解决它们。
每条规则都包括一个**强制实施**小节，列出了进行强制实施的一些建议。
所谓强制实施，可以是通过代码评审，通过静态分析，通过编译器，或者通过运行时检查来进行的。
只要可行，我们都倾向于“机械性的”检查（人类是缓慢的，不精确的，而且很容易疲倦）和静态检查。
只有当不存在其他方案时，我们才偶尔建议进行运行时检查；我们并不想带来所谓“分散肥肉”。
如果适当的话，我们会（在**强制实施**小节中）将规则标以相关的规则组的名字（所谓“剖面配置”）。
一条规则可以属于多个剖面配置，也可以不属于任何剖面配置。
首先，我们有一些对应于常规需求（期望、理想目标）的剖面配置：

* **type**: 消除类型违规（如通过强制转换（cast）、联合体（union）或者变参（varargs）把 `T` 重解释为 `U`）
* **bounds**: 消除边界违规（如越过数组范围的访问）
* **lifetime**: 消除泄漏（如未能 `delete` 或者进行多次 `delete`），以及消除对无效对象的访问（如解引用 `nullptr`，或使用悬挂引用）。

这些剖面配置是为工具的使用而准备的，但对人类读者也能有所帮助。
我们不打算把**强制实施**小节中的评述限定在我们了解如何强制实施的方面；其中的一些说明仅仅是一些愿望，它们可能会对一些工具构建者们造成影响。

实现这些规则的工具应当遵循下面的语法以明确抑制一条规则：

    [[suppress(tag)]]
    
其中的 "tag" 是包含强制规则的条目的锚定名字（例如，C.134 的锚定名字为 "Rh-public"），
剖面配置的规则组的名字（如 "type"，"bounds"，或 "lifetime"），或者剖面配置中的特定规则（"type.4" 或 "bounds.2"）。


## <a name="SS-struct"></a>In.struct: 本文档的结构

每条规则（指导方针，建议）可以包含几个部分：

* 规则本身 —— 例如，**不要使用裸 `new`**
* 一个规则参考编号 —— 例如，**C.7**（与类相关的第七条规则）。
  因为大章节之间天然是无序的，所以我们用一个字母来当作规则参考“编号”的第一个部分。
  我们在编号之间保留了一些间隔，以便当添加或删减规则时尽量减少“断裂”。
* **理由**（原理） —— 程序员对于他们不理解的规则是难于遵守的
* **示例** —— 抽象地理解规则是很难的；示例有正面的和负面的
* **替代方案** —— 针对“请勿……”规则
* **例外** —— 我们更喜欢简单的一般性规则。但是许多规则都是广泛适用，但并不是普遍适用的，因此必须列出例外情况
* **强制实施** —— 关于这条规则如何“机械性”地进行检查的建议
* **参见** —— 指向相关的规则，以及（本文档中或者别处的）进一步讨论
* **注解** —— 需要说明的一些内容，无法被归类到其他部分
* **探讨** —— 指向规则主列表之外的更加全面的原理说明和实例

一些规则难于机械地进行检查，但它们都满足一条最小准则，即专家程序员可以不费太多力气就能找出许多违反情况。
我们希望“机械性”工具能够随着时间获得改进，以接近这种专家程序员所能发觉的程度。
而且，我们还认为这些规则也会随着时间获得提炼，以变得更明确和易于检查。

规则应当简明，而不是谨慎地列出每种变化和特殊情况。
这些信息应当出现在**替代方案**段落和[探讨](#S-discussion)章节中。
如果您不理解或者反对一条规则，请您访问它的**探讨**部分。
如果您觉得一份探讨有缺漏或不完整，请填写一条 [Issue](https://github.com/isocpp/CppCoreGuidelines/issues)
来解释您的关切，亦或一条相应的问题报告。

本文档不是语言手册。
它旨在能够对人有所帮助，而不是变得完整，在技术细节上完全准确，或对现存代码的指南。
可以在[参考资料](#S-references)中找到一些推荐的信息来源。

## <a name="SS-sec"></a>In.sec: 主章节

* [In: 导言](#S-introduction)
* [P: 理念](#S-philosophy)
* [I: 接口](#S-interfaces)
* [F: 函数](#S-functions)
* [C: 类和类层次](#S-class)
* [Enum: 枚举](#S-enum)
* [R: 资源管理](#S-resource)
* [ES: 表达式和语句](#S-expr)
* [E: 错误处理](#S-errors)
* [Con: 常量和不可变性](#S-const)
* [T: 模板和泛型编程](#S-templates)
* [CP: 并发](#S-concurrency)
* [SL: 标准库](#S-stdlib)
* [SF: 源文件](#S-source)
* [CPL: C 风格的编程](#S-cpl)
* [PRO: 剖面配置](#S-profile)
* [GSL: 指导方针支持库](#S-gsl)
* [FAQ: 常见问题的解答](#S-faq)

配套章节：

* [NL: 命名和代码布局](#S-naming)
* [PER: 性能](#S-performance)
* [N: 伪规则和错误的看法](#S-not)
* [RF: 参考资料](#S-references)
* [附录 A: 程序库](#S-libraries)
* [附录 B: 代码的现代化](#S-modernizing)
* [附录 C: 相关讨论](#S-discussion)
* [词汇表](#S-glossary)
* [To-do: 未分类的规则原型](#S-unclassified)

章节之间并非是正交的。

每个章节（比如，"P" 代表“理念”），以及每个子章节（比如，"C.hier" 代表“类层次（OOP）”）都有一个用以简化搜索和引用的缩写。
主章节的缩写也出现在规则编号之中（比如，"C.11" 代表“使具体类型正规化”）。

# <a name="S-philosophy"></a>P: 理念

本章节中的规则都非常具有一般性。

理念性规则概览：

* [P.1: 在代码中直接表达你的想法](#Rp-direct)
* [P.2: 用 ISO 标准 C++ 来编码](#Rp-Cplusplus)
* [P.3: 表达你的设计意图](#Rp-what)
* [P.4: 理想情况下，程序应当是静态类型安全的](#Rp-typesafe)
* [P.5: 编译期检查优先于运行时检查](#Rp-compile-time)
* [P.6: 应当使无法在编译期进行的检查能够在运行时实施](#Rp-run-time)
* [P.7: 尽早识别运行时错误](#Rp-early)
* [P.8: 不要泄漏任何资源](#Rp-leak)
* [P.9: 不要浪费时间或空间](#Rp-waste)
* [P.10: 不可变数据优先于可变数据](#Rp-mutable)

通常，理念性的规则都无法机械性地进行检查。
不过，这些理念主题在各个规则中都有体现。
如果没有一个理念基础的话，那些更具体、专门和可检查的规则就是缺少理论根据的了。

### <a name="Rp-direct"></a>P.1: 在代码中直接表达你的想法

##### 理由

编译器是不会去读注释（或设计文档）的，许多程序员也（固执地）不去读它们。
而代码中所表达的东西是带有明确的语义的，并且（原则上）是可以由编译器和其他工具进行检验的。

##### 示例

    class Date {
        // ...
    public:
        Month month() const;  // 好
        int month();          // 不好
        // ...
    };

`month` 的第一个声明式，显然是要返回一个 `Month`，而且不会修改 `Date` 对象的状态。
而第二个版本则需要读者进行猜测，同时带来了更多的出现难于发现 BUG 的可能性。

##### 示例

    void do_something(vector<string>& v)
    {
        string val;
        cin >> val;
        // ...
        int index = -1;            // 不好
        for (int i = 0; i < v.size(); ++i)
            if (v[i] == val) {
                index = i;
                break;
            }
        // ...
    }

这个循环是 `std::find` 的一种能力有限的形式。
要清晰得多地表达其设计意图，可以这样：

    void do_something(vector<string>& v)
    {
        string val;
        cin >> val;
        // ...
        auto p = find(begin(v), end(v), val);  // 好多了
        // ...
    }

用恰当设计的程序库来表达设计意图（要做什么，而不只是怎么做这些事），要远比直接使用语言功能好得多。

C++ 程序员应当熟知标准库的基本知识，并在适当的时候加以利用。
任何程序员都应当熟知其所工作的项目中的基础程序库的基本知识，并适当加以利用。
使用本文档的指导方针的程序员，应当熟知[指导方针支持库](#S-gsl)，并适当加以利用。

##### 示例

    change_speed(double s);   // bad: s 代表什么？
    // ...
    change_speed(2.3);

更好的方案是明确给出这个 double 的含义（新的速度还是对旧速度的增量？）以及所用单位：

    change_speed(Speed s);    // 好多了：说明了 s 的含义
    // ...
    change_speed(2.3);        // 错误：没有单位
    change_speed(23m / 10s);  // 米每秒

确实可以用普通的（没有单位的）`double` 作为增量值，但这样是易于出错的。
如果绝对速度值和增量值都需要的话，我们应当定义一个 `Delta` 类型。

##### 强制实施

通常非常困难。

* 坚持一贯地使用 `const`（检查成员函数是否会修改对象；检查函数是否会修改以指针或引用形式传递的实参）
* 将强制转换标示出来（强制转换阉割了类型系统）
* 检测模仿标准库的代码（困难）

### <a name="Rp-Cplusplus"></a>P.2: 用 ISO 标准 C++ 来编码

##### 理由

本文档正是关于用 ISO 标准 C++ 来编码的一组指导方针。

##### 注解

有些环境下是需要使用语言扩展的，例如有关访问系统资源的语言扩展。
这些情况下，应当将对所需语言扩展的使用局部化，并把它们的使用置于非核心的编码指导方针的控制之下。如果可能的话，应当构建一些接口来封装这些语言扩展，以使其能够被关闭，并当针对不支持这些语言扩展的系统时免除它们的编译。

语言扩展通常是没有严密定义的语义的。即便语言扩展很常见，
并且在多种编译器上都有实现，它们也可能有略微不一致的行为
以及边界情形下的行为，这是*缺乏*一个严格的标准定义的
直接后果。大量使用任何这样的语言扩展，都会对代码的可移植性
造成不良影响。

##### 注解

有些环境下是需要对标准 C++ 语言或者程序库的功能特性的使用进行限制的，例如，飞行器控制软件标准要求避免动态内存分配。
这些情况下，应当将对它们的使用（或废弃）置于对本文档针对特定环境所定制的扩充的编码指导方针之下。

##### 强制实施

使用最新版的 C++ 编译器（当前支持 C++11 或者 C++14），并打开禁用语言扩展的选项。

### <a name="Rp-what"></a>P.3: 表达你的设计意图

##### 理由

一些代码如果不（比如通过命名或者代码注释）说明其设计意图的话，是不可能搞清楚代码是否达成其预定目标的。

##### 示例

    int i = 0;
    while (i < v.size()) {
        // ... 在 v[i] 上做一些事 ...
    }

这里并未表明其意图是“单纯地”循环访问 `v` 的元素。使用一个索引的实现细节被暴露了出来（因而可能导致被误用），而且 `i` 的存在超出了循环的范围，这也许符合也许违背了设计意图。读者仅从这段代码中是无法了解清楚的。

更好的方式是：

    for (const auto& x : v) { /* 在 x 上做一些事 */ }

现在，循环机制不明确给出，而且循环的操作针对的是 `const` 元素，以防止发生意外的修改。如果需要进行修改的话，则可以这样：

    for (auto& x : v) { /* 在 x 上做一些事 */ }

有时候，使用具名的算法会更好：

    for_each(v, [](int x) { /* 在 x 上做一些事 */ });
    for_each(parallel.v, [](int x) { /* 在 x 上做一些事 */ });

最后一种写法让人明白，我们对按照何种顺序来处理 `v` 的各个元素并不关心。

程序员应当熟悉：

* [指导方针支持库](#S-gsl)
* [ISO C++ 标准库](#S-stdlib)
* 当前项目所使用的任何基础程序库

##### 注解

其他形式：说明要做什么，而不只是怎么做这些事。

##### 注解

一些语言构造比另一些可以更好地表达设计意图。

##### 示例

如果要用两个 `int` 来代表二维点的坐标值，应当这样：

      drawline(int, int, int, int);  // 含混的
      drawline(Point, Point);        // 清晰的

##### 强制实施

查找具有更加替代方案的一般模式：

* 简单 `for` 循环 vs. 范围式 `for` 循环
* `f(T*, int)` 接口 vs. `f(span<T>)` 接口
* 循环变量出现在过大的范围中
* 裸的 `new` 和 `delete`
* 带有大量内建类型参数的函数

在聪敏的人工处理和半自动的程序变换之间存在巨大的空间。

### <a name="Rp-typesafe"></a>P.4: 理想情况下，程序应当是静态类型安全的

##### 理由

理想情况下，程序应当完全是静态（编译期）类型安全的。
不幸的是，这是不可能的。有问题的领域：

* `union`
* 强制转换
* 数组衰退
* 范围错误
* 窄化转换

##### 注解

这些领域是许多严重问题（如程序崩溃和安全性违规）的来源。
我们争取为它们给出替代技术。

##### 强制实施

如果程序各自需要或者条件允许的话，我们可以逐个对这些问题类型分别进行阻止、克制或者检测。
我们总会给出替代方案。
例如：

* `union` - 使用 `variant`
* 强制转换 - 尽可能减少其使用；使用模板有助于这点
* 数组衰退 - 使用 `span`
* 范围错误 - 使用 `span`
* 窄化转换 - 尽可能减少其使用，必须使用时则使用 `narrow` 或者 `narrow_cast`

### <a name="Rp-compile-time"></a>P.5: 编译期检查优先于运行时检查

##### 理由

为了代码清晰性和性能。对于编译期识别的错误是不需要编写错误处理的。

##### 示例

    void initializer(Int x)
    // Int 被用作整数的别名
    {
        static_assert(sizeof(Int) >= 4);    // do: 编译期检查

        int bits = 0;         // don't: avoidable code
        for (Int i = 1; i; i <<= 1)
            ++bits;
        if (bits < 32)
            cerr << "Int too small\n";

        // ...
    }

##### 示例：请避免

    void read(int* p, int n);   // 读取至多 n 个整数到 *p 之中

##### 示例

    void read(span<int> r); // 读取到整数区域范围 r 之中

**替代形式**: 不要把可以在编译期搞定的事推后到运行时进行。

##### 强制实施

* 查找指针参数。
* 查找运行时进行的范围违反检查。

### <a name="Rp-run-time"></a>P.6: 应当使无法在编译期进行的检查能够在运行时实施

##### 理由

把难于检测的错误遗留在程序中，总会带来程序崩溃或得到错误的运行结果。

##### 注解

理想情况下我们可以在编译期或者运行时识别所有的错误（它们并非程序员的逻辑错误）。但是要在编译期识别所有的错误是不可能的，而通常也负担不起在运行时识别剩余的全部错误的代价。不过我们编写程序，应当尽量使其在原则上是可以在充足的（分析程序，运行时检查，机器资源，时间等）资源下进行检查的。

##### 示例，不好

    extern void f(int* p);  // 分离编译，可能会被动态加载

    void g(int n)
    {
        f(new int[n]);  // 不好的：并未把元素数量传递给 f()
    }

此处，关键性的信息（元素数量）被完全掩盖起来，使其无法进行静态分析，而如果 `f()` 属于某个 ABI 的一部分的话，由于无法对这个指针进行“测量插装”，运行时检查也是不可行的。我们确实可以在自由存储中插入有助于检查的信息，但这需要对系统甚至是编译器做出整体改动。这就是一个能让错误检查变得非常困难的设计。

##### 示例，不好

当然可以把元素数量和指针一起进行传递：

    extern void f2(int* p, int n);  // 分离编译，可能会被动态加载

    void g2(int n)
    {
        f2(new int[n], m);    // 不好的：可能会把错误的元素数量传递给 f()
    }

把元素数量作为一个参数进行传递，比只传递指针而依靠某种（不明确的）对已知元素个数的约定或者找出元素个数的方式，要好得多，而且是更加常见的做法。但是如上所示，一个简单的错字就可以引入一个严重的错误。`f2()` 的两个参数之间的关联是基于约定的，而并不明确。

而且，这里还隐含假定 `f2()` 应当 `delete` 其参数（要不然就是调用者又犯了另一个错误）。

##### 示例，不好

使用标准库的资源管理指针指向对象时，也不能传递其大小：

    extern void f3(unique_ptr<int[]>, int n);    // 分离编译，可能会被动态加载
                                                 // NB: 这里假定调用代码是 ABI 兼容的，使用的是
                                                 // 兼容的 C++ 编译器和同一个 stdlib 实现

    void g3(int n)
    {
        f3(make_unique<int[]>(n), m);    // 不好的：把所有权和大小分开进行传递
    }

##### 示例

我们得把指针和元素数量作为一个对象整体来进行传递：

    extern void f4(vector<int>&);       // 分离编译，可能会被动态加载
    extern void f4(span<int>);          // 分离编译，可能会被动态加载
                                                 // NB: 这里假定调用代码是 ABI 兼容的，使用的是
                                                 // 兼容的 C++ 编译器和同一个 stdlib 实现

    void g3(int n)
    {
        vector<int> v(n);
        f4(v);                     // 传递引用，保留所有权
        f4(span<int>{v});    // 传递视图，保留所有权
    }

这个设计将元素数量作为对象的固有部分，因此不太可能有错误，动态（运行时的）检查即使不总是可承担的，也总是可行的。

##### 示例

如果把所有权和验证所需的全部信息一起传递的话会怎么样呢？

    vector<int> f5(int n)    // OK: 移动
    {
        vector<int> v(n);
        // ... 初始化 v ...
        return v;
    }

    unique_ptr<int[]> f6(int n)    // 不好的：缺失了 n
    {
        auto p = make_unique<int[]>(n);
        // ... 初始化 *p ...
        return p;
    }

    owner<int*> f7(int n)    // 不好的：缺失了 n 并且我们可能会忘记 delete
    {
        owner<int*> p = new int[n];
        // ... 初始化 *p ...
        return p;
    }

##### 示例

* ???
* 展示传递多态基类的接口是如何避开可能进行的检查的，但它们实际上直到它们需要的类型？
  还有用字符串当作“自由式”选项的做法

##### 强制实施

* 标示出 (pointer, count) 形式的接口（这将标示出大量的因为兼容性原因而无法进行修正的实例）
* ???

### <a name="Rp-early"></a>P.7: 尽早识别运行时错误

##### 理由

避免“神秘的”程序崩溃。
避免能够产生（也许无法识别的）错误结果的程序错误。

##### 示例

    void increment1(int* p, int n)    // 不好的：易于出错
    {
        for (int i = 0; i < n; ++i) ++p[i];
    }

    void use1(int m)
    {
        const int n = 10;
        int a[n] = {};
        // ...
        increment1(a, m);   // 可能是打错字，可能假定有 m <= n
                            // 不过让我们假设 m == 20
        // ...
    }

我们在 `use1` 里面犯了一个能够导致数据损坏或程序崩溃的小错误。
这个 (pointer, count) 形式的接口让 `increment1()` 没有可以使其防范越界错误的任何现实可行的方式。
假设我们可以检测到越界访问的下标，那么这个错误直到对 `p[10]` 进行访问之前都不会被发现。
我们可以提早进行检查来改进这个代码：

    void increment2(span<int> p)
    {
        for (int& x : p) ++x;
    }

    void use2(int m)
    {
        const int n = 10;
        int a[n] = {};
        // ...
        increment2({a, m});    // 可能是打错字，可能假定有 m<=n
        // ...
    }

现在，就可以在调用点（提早地）检查 `m<=n`，而不是更晚进行了。
如果我们只是打错了字而本想用 `n` 作为边界值的话，代码还可以进一步简化（来消除一处错误的可能性）：

    void use3(int m)
    {
        const int n = 10;
        int a[n] = {};
        // ...
        increment2(a);   // 不需要重复给出 a 的元素数量
        // ...
    }

##### 示例，不好

不要对同一个值重复进行检查。不要用字符串来传递有结构的数据：

    Date read_date(istream& is);    // 从 istream 读取日期

    Date extract_date(const string& s);    // 从 string 中抽取日期

    void user1(const string& date)    // 操作 date
    {
        auto d = extract_date(date);
        // ...
    }

    void user2()
    {
        Date d = read_date(cin);
        // ...
        user1(d.to_string());
        // ...
    }

这个日期被（`Date` 的构造函数）验证了两次，并以字符串（无结构的数据）的形式来传递。

##### 示例

过量的检查可能是代价昂贵的。
有些情况下提早检查可能是愚蠢的，因为你可能根本不需要这个值，或者可能仅需要值的一部分，而这要比进行整体的检查容易得多。同样来说，不要添加能够改变接口的渐进式行为的验证性检查（例如，不要在平均复杂度为 `O(1)` 的接口中添加一个 `O(n)` 的检查）。

    class Jet {    // 物理规则是: e*e < x*x + y*y + z*z

        float x;
        float y;
        float z;
        float e;
    public:
        Jet(float x, float y, float z, float e)
            :x(x), y(y), z(z), e(e)
        {
            // 应不应该在这里检查这些值是物理上有意义的？
        }

        float m() const
        {
            // 应不应该处理这里的退化情形？
            return sqrt(x*x + y*y + z*z - e*e);
        }

        ???
    };

喷流（Jet）的物理定律（`e*e < x*x + y*y + z*z`），由于可能存在测量误差的缘故并不是不变式。

???

##### 强制实施

* 查找指针和数组：提早进行范围检查
* 查找类型转换：消除或标示出窄化转换
* 查找未经检查的来自输入的值。
* 查找被转换成字符串的结构化数据（带有不变式的类的对象）
* ???

### <a name="Rp-leak"></a>P.8: 不要泄漏任何资源

##### 理由

即使是缓慢的资源增长，随着时间推移，也会耗尽这些资源的可用性。
这对于长时间运行的程序来说尤其重要，而且是负责任的编程行为的基础方面。

##### 示例，不好

    void f(char* name)
    {
        FILE* input = fopen(name, "r");
        // ...
        if (something) return;   // 不好的：如果 something == true 的话，将会泄漏一个文件句柄
        // ...
        fclose(input);
    }

建议采用 [RAII](#Rr-raii)：

    void f(char* name)
    {
        ifstream input {name};
        // ...
        if (something) return;   // OK: 没有泄漏
        // ...
    }

**参见**: [资源管理相关章节](#S-resource)

##### 注解

通俗地说，泄漏就是“有东西没清理干净”。一种更重要的
分类方式是“有东西无法再被清理干净”。例如，在堆上
分配一个对象，然后又丢失了最后一个指向这份分配物
的指针。不应当将这条规则误读为，要求在程序终止时
必须把长期存活的对象中的分配物进行回收。（虽然如果
它们确实可以被清理掉并进行安全地回收的话也应当这样做。）

##### 注解

强制实行[生存期剖面配置](#In.force)可以消除泄漏的发生。
如果和 [RAII](#Rr-raii) 所提供的资源安全性组合到一起，也可以（通过不产生任何垃圾而）消除对“垃圾收集”的需要。
如果将之和[类型和边界剖面配置](#In.force) 组合到一起强制实施的话，你将会得到完全的类型和资源安全性，这是通过使用工具来保证的。

##### 强制实施

* 查找指针：把它们分成非所有者（默认情形）和所有者。
  如果可行的话，把所有者替换为标准库的资源封装类（如上例所示）。
  或者，也可以把这种所有者用 [GSL](#S-gsl) 中的 `owner` 进行标记。
* 查找裸露的 `new` 和 `delete`
* 查找已知的返回原始指针的资源分配函数（诸如 `fopen`，`malloc`，和 `strdup` 等）

### <a name="Rp-waste"></a>P.9: 不要浪费时间或空间

##### 理由

你用的语言是 C++。

##### 注解

为达成某个目标（例如开发速度，资源安全性，或者测试的简化等）而正当花费的时间和空间是不会被浪费的。
“力求高效的另一种好处是，这一过程将强迫你更深入地理解问题。”—— Alex Stepanov

##### 示例，不好

    struct X {
        char ch;
        int i;
        string s;
        char ch2;

        X& operator=(const X& a);
        X(const X&);
    };

    X waste(const char* p)
    {
        if (p == nullptr) throw Nullptr_error{};
        int n = strlen(p);
        auto buf = new char[n];
        if (buf == nullptr) throw Allocation_error{};
        for (int i = 0; i < n; ++i) buf[i] = p[i];
        // ... 对缓冲区进行操作 ...
        X x;
        x.ch = 'a';
        x.s = string(n);    // 在 x.s 上预留 *ps 的空间
        for (int i = 0; i < x.s.size(); ++i) x.s[i] = buf[i];  // 把 buf 复制给 x.s
        delete buf;
        return x;
    }

    void driver()
    {
        X x = waste("Typical argument");
        // ...
    }

这个确实有些夸张，但我们在产品代码中能够见到这里所犯的每个错误，甚至更糟糕。
注意，`X` 的布局保证会浪费至少 6 个字节，而且很可能更多。
错误的复制操作的定义式废掉了移动语义，使返回操作变得更慢。
为 `buf` 使用的 `new` 和 `delete` 是多余的；如果确实想要一个局部的字符串的话，我们应当使用局部的 `string`。
还有几个其他的性能 BUG 和无理由的复杂性。

##### 示例，不好

    void lower(zstring s)
    {
        for (int i = 0; i<strlen(s); ++s) s[i] = tolower(s[i]);
    }

这个其实是一个来自产品代码的例子。
我们留给读者来找出这里浪费了什么东西。

##### 注解

单个造成浪费的范例很少是显著的，而一旦它是显著的，通常也可以被高手轻易地清除掉。
但是，代码库中放任地到处散布的浪费情况，则很容易变得显著，而高手们又不像我们期望那样总是有空的。
本条规则（以及其他配套的更加具体的规则）的目的是，将与 C++ 语言的使用有关的大多数浪费情况，在其发生之前就将之清除掉。
在这之后，我们就可以查找与算法和需求有关的浪费情况了，但这超出了我们的指导方针的范畴。

##### 强制实施

许多更加具体的规则都是针对追求简单性并清除无理由浪费的总体目标的。

### <a name="Rp-mutable"></a>P.10: 不可变数据优先于可变数据

##### 理由

对常量进行推理要比变量简单得多。
不可变的事物是不可能被意外改变的。
不可变性有时候也带来更好地进行优化的机会。
在常量上不会出现数据竞争。

另见 [Con: 常量和不可变性](#S-const)



# <a name="S-interfaces"></a>I: 接口

接口是程序中的两个部分之间的契约。严格地规定服务提供者和该服务使用者的预期是必要的。
在代码的组织中，良好的接口（易于理解，促进高效的使用方式，不易出错，支持进行测试，等等）可能是最重要的单个方面了。

接口规则概览：

* [I.1: 使接口明确](#Ri-explicit)
* [I.2: 避免全局变量](#Ri-global)
* [I.3: 避免使用单例](#Ri-singleton)
* [I.4: 使接口严格和强类型化](#Ri-typed)
* [I.5: 说明前条件（如果有）](#Ri-pre)
* [I.6: 优先使用 `Expects()` 来表达前条件](#Ri-expects)
* [I.7: 说明后条件](#Ri-post)
* [I.8: 优先使用 `Ensures()` 来表达后条件](#Ri-ensures)
* [I.9: 当接口是模板时，用概念来文档化其参数](#Ri-concepts)
* [I.10: 使用异常来表明无法实施所要求的任务](#Ri-except)
* [I.11: 决不以原始指针（`T*`）来传递所有权](#Ri-raw)
* [I.12: 把不能为空的指针声明为 `not_null`](#Ri-nullptr)
* [I.13: 不要只用一个指针来传递数组](#Ri-array)
* [I.22: 避免全局对象之间进行复杂的初始化](#Ri-global-init)
* [I.23: 保持较少的函数参数数量](#Ri-nargs)
* [I.24: 避免出现相邻而无关的相同类型的参数](#Ri-unrelated)
* [I.25: 优先以抽象类作为类层次的接口](#Ri-abstract)
* [I.26: 当想要跨编译器的 ABI 时，使用一个 C 风格的语言子集](#Ri-abi)

参见

* [F: 函数](#S-functions)
* [C.concrete: 具体类型](#SS-concrete)
* [C.hier: 类层次](#SS-hier)
* [C.over: 函数重载和重载运算符](#SS-overload)
* [C.con: 容器和其他资源封装类](#SS-containers)
* [E: 错误处理](#S-errors)
* [T: 模板和泛型编程](#S-templates)

### <a name="Ri-explicit"></a>I.1: 使接口明确

##### 理由

正确性。未在接口中规定的假设很容易被忽视而且难于测试。

##### 示例，不好

通过全局（命名空间作用域）变量（调用模式）来控制函数的行为，是隐含的，而且潜在会造成困惑。例如：

    int rnd(double d)
    {
        return (rnd_up) ? ceil(d) : d;    // 请勿：“不可见的”依赖
    }

两次调用 `rnd(7.2)` 的含义可能给出不同的结果，这对于调用者来说是不明显的。

**例外**: 我们有时候会通过环境变量来控制一组操作的细节，比如常规/详细的输出，或者调试/优化版本。
使用非局部的控制方式可能带来困惑，但可以只用来控制实现的细节，否则就只有固定的语义了。

##### 示例，不好

通过非局部变量（比如 `errno`）进行的报告经常被忽略。例如：

    fprintf(connection, "logging: %d %d %d\n", x, y, s); // 请勿：printf 的返回值未进行检查

要是连接已经关闭而导致没有产生日志输出的话会怎么样？参见 I.??。

**替代方案**: 抛出异常。异常是无法被忽略的。

**其他形式**: 避免通过非局部或者隐含的状态来跨越接口传递信息。
注意，非 `const` 的成员函数会通过对象的状态来向其他成员函数传递信息。

**其他形式**: 接口应当是函数或者一组函数集合。
函数可以是模板函数，而函数集合可以是类或者类模板。

##### 强制实施

* 【简单】 函数不能基于声明于命名空间作用域的变量来作出影响控制流的决定。
* 【简单】 函数不能对声明于命名空间作用域的变量进行写入操作。

### <a name="Ri-global"></a>I.2 避免全局变量

##### 理由

非 `const` 全局变量能够隐藏依赖关系，并使这些依赖项可能出现无法预测的变动。

##### 示例

    struct Data {
        // ... 大量成员 ...
    } data;            //  非 const 数据

    void compute()     // 请勿这样做
    {
        // ... 使用 data ...
    }

    void output()     // 请勿这样做
    {
        // ... 使用 data ...
    }

哪个可能会修改 `data` 呢？

##### 注解

全局常量是有益的。

##### 注解

针对全局变量的规则同样适用于命名空间作用域的变量。

**替代方案**: 如果你用全局数据（或者更一般地说命名空间作用域的数据）来避免复制操作的话，请考虑把数据以 const 引用的形式进行传递的方案。
另一种方案是把数据定义为某个对象的状态，而把操作定义为其成员函数。

**警告**: 请关注数据竞争：当一个线程能够访问非局部数据（或以引用传递的数据），而另一个线程执行被调用的函数时，就可能带来数据竞争。
指向可变数据的每个指针或引用都是潜在的数据竞争。

##### 注解

不可变数据是不会带来数据竞争条件的。

**参见**: 另见[关于调用函数的规则](#SS-call)。

##### 强制实施

【简单】 报告所有在命名空间作用域中声明的非 `const` 变量。

### <a name="Ri-singleton"></a>I.3: 避免使用单例

##### 理由

单例基本上就是经过伪装的更复杂的全局对象。

##### 示例

    class Singleton {
        // ... 大量代码，用于确保只创建一个 Singleton，
        // 进行正确地初始化，等等
    };

单例的想法有许多变种。
这也是问题的一方面。

##### 注解

如果不想让全局对象被改变，请将其声明为 `const` 或 `constexpr`。

##### 例外

你可以使用最简单的“单例”形式（简单到通常不被当作单例）来获得首次使用时进行初始化的效果：

    X& myX()
    {
        static X my_x {3};
        return my_x;
    }

这是解决初始化顺序相关问题的最有效方案之一。
在多线程环境中，静态对象的初始化并不会引入数据竞争条件
（除非你不小心在其构造函数中访问了某个共享对象）。

如果你和许多人一样把单例定义为只能创建一个对象的类的话，像 `myX` 这样的函数并非单例，而且这种好用的技巧并不算无单例规则的例外。

##### 强制实施

通常非常困难。

* 查找名字中包含 `singleton` 的类。
* 查找只创建一个对象的类（通过对对象计数或者检查其构造函数）。
* 如果某个类 X 具有公开的静态函数，并且它包含具有该类 X 类型的函数级局部静态变量并返回指向它的指针或者引用，就禁止它。

### <a name="Ri-typed"></a>I.4: 使接口严格和强类型化

##### 理由

类型是最简单和最好的文档，它们有定义明确的含义，并且保证在编译期进行检查。
而且，严格类型化的代码通常也能更好地进行优化。

##### 示例，请勿这样做

考虑：

    void pass(void* data);    // void* 是有问题的

被调用方必须得把数据指针强制转换（回）正确的类型以能使用它。这样做易于犯错，而且通常是多余的。
请避免 `void*`，尤其是在接口中。
请考虑使用 `variant` 或指向基类的指针来代替它。（前景注记：考虑使用指向概念的指针。）

**替代方案**: 通常，利用模板形参可以把 `void*` 排除而改为 `T*` 或者 `T&`。

##### 示例，不好

考虑：

    void draw_rect(int, int, int, int);   // 很大的犯错机会

    draw_rect(p.x, p.y, 10, 20);          // 10, 20 是什么意思？

`int` 可以携带任何形式的信息，因此我们必须猜测这四个 `int` 的含义。
前两个最可能的是坐标对 `x`,`y`，但后两个是什么呢？
注释和参数的名字可以有所帮助，但我们可以直截了当：

    void draw_rectangle(Point top_left, Point bottom_right);
    void draw_rectangle(Point top_left, Size height_width);

    draw_rectangle(p, Point{10, 20});  // 两个角点
    draw_rectangle(p, Size{10, 20});   // 一个角和一对 (height, width)

显然，我们是无法利用静态类型系统识别所有的错误的，
例如，假定第一个参数是左上角这一点就依赖于约定（命名或者注释）。

##### 示例，不好

下例中，接口中并未明确给出 `time_to_blink` 的含义：按秒还是按毫秒算？

    void blink_led(int time_to_blink) // 不好 - 在单位上含糊
    {
        // ...
        // 对 time_to_blink 做一些事
        // ...
    }

    void use()
    {
        blink_led(2);
    }

##### 示例，好

C++11 所引入的 `std::chrono::duration` 类型可以让时间段的单位明确下来。

    void blink_led(milliseconds time_to_blink) // 好 - 单位明确
    {
        // ...
        // 对 time_to_blink 做一些事
        // ...
    }

    void use()
    {
        blink_led(1500ms);
    }

这个函数还可以写成使其接受任何时间段单位的形式。

    template<class rep, class period>
    void blink_led(duration<rep, period> time_to_blink) // 好 - 接受任何单位
    {
        // 假设最小的有意义单位是毫秒
        auto milliseconds_to_blink = duration_cast<milliseconds>(time_to_blink);
        // ...
        // 对 milliseconds_to_blink 做一些事
        // ...
    }

    void use()
    {
        blink_led(2s);
        blink_led(1500ms);
    }

##### 强制实施

* 【简单】 报告将 `void*` 用作参数或返回类型的情况
* 【难于做好】 查找带有许多内建类型的参数的成员函数。

### <a name="Ri-pre"></a>I.5: 说明前条件（如果有）

##### 理由

在参数上蕴含着使它们在被调用方中能够恰当使用的约束关系。

##### 示例

考虑：

    double sqrt(double x);

这里 `x` 必须是非负数。类型系统是无法（简洁并自然地）表达这点的，因而我们得用别的方法。例如：

    double sqrt(double x); // x 必须是非负数

一些前条件可以表示为断言。例如：

    double sqrt(double x) { Expects(x >= 0); /* ... */ }

理想情况下，这个 `Expects(x >= 0)` 应当是 `sqrt()` 的接口的一部分，但我们无法轻易做到这点。当前，我们将之放入定义式（函数体）之中。

**参考**: `Expects()` 在 [GSL](#S-gsl) 中有说明。

##### 注解

优先使用正式的必要条件说明，比如 `Expects(p != nullptr);`。如果这样不可行，就在注释中使用文字来说明，比如
`// 序列 [p:q) 根据 < 排序`。

##### 注解

许多成员函数都以某个类所保持的不变式作为一项前条件。
这个不变式是由构造函数所建立的，且必须在被从类之外所调用的每个成员函数的退出时重新建立。
我们并不需要对每个成员函数都说明这个不变式。

##### 强制实施

【无法强制实施】

**参见**: 有关传递指针的规则。???

### <a name="Ri-expects"></a>I.6: 优先使用 `Expects()` 来表达前条件

##### 理由

清晰地表明这个条件是一个前条件，并便于工具的利用。

##### 示例

    int area(int height, int width)
    {
        Expects(height > 0 && width > 0);            // 好
        if (height <= 0 || width <= 0) my_error();   // 隐晦的
        // ...
    }

##### 注解

前条件是可以用许多方式来说明的，包括代码注释，`if` 语句，以及 `assert()`。这些方式使其难于与普通代码之间进行区分，难于进行更新，难于利用工具来操作，而且可能具有错误的语义（你真的总是想要在调试模式中止程序而在生产运行中不做任何检查吗？）

##### 注解

前条件应当是接口的一部分，而不是实现的一部分，但我们至今还没有能够做到这点的语言设施。

##### 注解

`Expects()` 还可以用于在算法的中部来检查某个条件。

##### 强制实施

【无法强制实施】 要把各种对前条件进行断言的方式都找出来是不可行的。对那些易于识别的（如 `assert()`）实例给出警告的做法，其意义在缺少语言设施的前提下是有问题的。

### <a name="Ri-post"></a>I.7: 说明后条件

##### 理由

以检测到对返回结果的误解，还可能发现实现中存在错误。

##### 示例，不好

考虑：

    int area(int height, int width) { return height * width; }  // 不好

这里，我们（粗心大意地）遗漏了前条件的说明，因此高度和宽度必须是正数这点是不明确的。
我们也遗漏了后条件的说明，因此算法（`height * width`）对于大于最大整数的面积来说是错误的这点是不明显的。
可能会有溢出。
应该考虑使用：

    int area(int height, int width)
    {
        auto res = height * width;
        Ensures(res > 0);
        return res;
    }

##### 示例，不好

考虑一个著名的安全性 BUG：

    void f()    // 有问题的
    {
        char buffer[MAX];
        // ...
        memset(buffer, 0, MAX);
    }

由于没有后条件来说明缓冲区应当被清零，优化器可能会将这个看似多余的 `memset()` 调用给清除掉：

    void f()    // 有改进
    {
        char buffer[MAX];
        // ...
        memset(buffer, 0, MAX);
        Ensures(buffer[0] == 0);
    }

##### 注解

后条件通常是在说明函数目的的代码注释中非正式地进行说明的；用 `Ensures()` 可以使之更加系统化，更加明显，并且更容易检查。

##### 注解

后条件对于那些无法在所返回的结果中直接体现的东西来说尤其重要，比如要说明所用的数据结构。

##### 示例

考虑一个操作 `Record` 的函数，它使用 `mutex` 来避免数据竞争条件：

    mutex m;

    void manipulate(Record& r)    // 请勿这样做
    {
        m.lock();
        // ... 没有 m.unlock() ...
    }

这里，我们“忘记”说明应当释放 `mutex`，因此我们搞不清楚这里 `mutex` 释放的缺失是一个 BUG 还是一种功能特性。
把后条件说明将使其更加明确：

    void manipulate(Record& r)    // 后条件: m 在退出后是未锁定的
    {
        m.lock();
        // ... 没有 m.unlock() ...
    }

现在这个 BUG 就明显了（但仅对阅读了代码注释的人类来说）。

更好的做法是使用 [RAII](#Rr-raii) 来在代码中保证后条件（“锁必须进行释放”）的实施：

    void manipulate(Record& r)    // 最好这样
    {
        lock_guard<mutex> _ {m};
        // ...
    }

##### 注解

理想情况下，后条件应当在接口或声明式中说明，让使用者易于见到它们。
只有那些与使用者有关的后条件才应当在接口中说明。
仅与内部状态相关的后条件应当属于定义式或实现。

##### 强制实施

【无法强制实施】 这是一条理念性的指导方针，一般情况下进行直接的
检查是不可行的。不过许多工具链中都有适用于特定领域的检查器，
比如针对锁定持有情况的检查器。

### <a name="Ri-ensures"></a>I.8: 优先使用 `Ensures()` 来表达后条件

##### 理由

清晰地表明这个条件是一个后条件，并便于工具的利用。

##### 示例

    void f()
    {
        char buffer[MAX];
        // ...
        memset(buffer, 0, MAX);
        Ensures(buffer[0] == 0);
    }

##### 注解

后条件是可以用许多方式来说明的，包括代码注释，`if` 语句，以及 `assert()`。这些方式使其难于与普通代码之间进行区分，难于进行更新，难于利用工具来操作，而且可能具有错误的语义。

**替代方案**: 如“这个资源必须被释放”这样形式的后条件最好以 [RAII](#Rr-raii) 的方式来表达。

理想情况下，`Ensures` 应当是接口的一部分，但我们无法轻易做到这点。当前，我们将之放入定义式（函数体）之中。

##### 强制实施

【无法强制实施】 要把各种对后条件进行断言的方式都找出来是不可行的。对那些易于识别的（如 `assert()`）实例给出警告的做法，其意义在缺少语言设施的前提下是有问题的。

### <a name="Ri-concepts"></a>I.9: 当接口是模板时，用概念来文档化其参数

##### 理由

更严谨地说明接口，并使其在（不远的）将来可以在编译时进行检查。

##### 示例

使用 ISO Concepts TS 风格的必要条件说明。例如：

    template<typename Iter, typename Val>
    // requires InputIterator<Iter> && EqualityComparable<ValueType<Iter>>, Val>
    Iter find(Iter first, Iter last, Val v)
    {
        // ...
    }

##### 注解

很快（可能是 2016 年），大多数编译器就有能力检查删除了 `//` 之后的 `requires` 子句了。

**参见**: 另见[泛型编程](#SS-GP)和[概念](#SS-t-concepts)。

##### 强制实施

【还无法强制实施】 当前正在对一种语言设施进行规范化。一旦这种语言设施出现，就可以对未被概念所约束（在其声明式之中或者在一个 `requires` 子句中所给出）的并非可变数量的模板形参作出警告了。

### <a name="Ri-except"></a>I.10: 使用异常来表明无法实施所要求的任务

##### 理由

不应该让错误可以被忽略，因为这将导致系统或者一次运算进入未定义的（或者预料之外的）状态。
这是错误的一个主要来源。

##### 示例

    int printf(const char* ...);    // 不好: 当输出失败时返回负值

    template <class F, class ...Args>
    explicit thread(F&& f, Args&&... args);    // 好: 当无法启动一个新的线程时抛出 system_error

##### 注解： 错误是什么？

错误的含义是函数无法达成其所宣称的目标（这包括后条件的建立）。
把错误忽略掉的调用方代码将导致错误的结果，或者未定义的系统状态。
例如，无法连接一个远程服务器本身并不是错误：
这个服务器可以因为各种原因而拒绝连接，因此合乎常理的方式是让其返回一个其调用者必然要检查的结果。
不过，如果无法连接本身就是被当作一种错误的话，这个失败时应当抛出一个异常。

**例外**: 许多传统的接口函数（比如 UNIX 的信号处理器）都使用错误代码（就是 `errno`）来报告其实是状态代码而不是错误的东西。你没有更好的选择只能用它，因此对其调用并不违反本条规则。

**替代方案**: 如果你不能使用异常（比如说由于你的代码全都是老式的原始指针用法，或者由于你有硬实时性的约束），请考虑使用返回一对值的代码风格：

    int val;
    int error_code;
    tie(val, error_code) = do_something();
    if (error_code == 0) {
        // ... 处理错误或者退出 ...
    }
    // ... 使用 val ...

##### 注解

我们并不认为“性能”是一种不使用异常的合理理由。

* 通常，显式的错误检查和处理会消耗掉和异常处理一样多的时间和空间。
* 通常，使用异常的更清晰的代码会带来更好的性能（简化了对程序执行路径的追踪和其优化）。
* 一条对性能关键代码的好规则是，把检查从代码的关键部分中移出去（[检查](#Rper-checking)）。
* 长期来看，更规整的代码会得到更好的优化。

**参见**: [I.5](#Ri-pre) 和 [I.7](#Ri-post) 有关报告前条件和后条件的违反。

##### 强制实施

* 【无法强制实施】 这是一条理念性的指导方针，进行直接的检查是不可行的。
* 查找 `errno`。

### <a name="Ri-raw"></a>I.11: 决不以原始指针（`T*`）来传递所有权

##### 理由

如果对调用者和被调用方哪一个拥有对象有疑问，那就会造成泄漏或者发生提早的析构。

##### 示例

考虑：

    X* compute(args)    // 请勿这样做
    {
        X* res = new X{};
        // ...
        return res;
    }

应当由谁来删除返回的这个 `X` 呢？如果 `compute` 返回引用的话这个问题将更难发现。
应该考虑按值来返回结果（如果结果比较大的话就用移动语义）：

    vector<double> compute(args)  // 好的
    {
        vector<double> res(10000);
        // ...
        return res;
    }

**替代方案**: 用“智能指针”来传递所有权，比如 `unique_ptr`（专有所有权）和 `shared_ptr`（共享所有权）。
不过除非你需要引用语义，否则这样做并没有那么简炼和高效。

**替代方案**: 有时候因为 ABI 兼容性的要求或者缺少资源，是无法对老代码进行修改的。
这种情况下，请用 `owner` 来标记拥有对象的指针：

    owner<X*> compute(args)    // 现在就明确传递了所有权这一点
    {
        owner<X*> res = new X{};
        // ...
        return res;
    }

这告诉了分析工具 `res` 是一个所有者。
就是说，它的值必须被 `delete`，或者被传递给另一个所有者，正如这里的 `return` 所做。

在资源包装类的实现中也同样使用了 `owner`。

`owner` 定义于[指导方针支持库](#S-gsl)之中。

##### 注解

以原始指针（或迭代器）的形式传递的对象，都假定是由调用方
所有的，因此其生存期也由调用方来处理。换种方式来看：
传递所有权的 API 相对于传递指针的 API 来说比较少见，
因此缺省情况就是“不传递所有权”。

**参见**: [实参传递](#Rf-conventional)和[返回值](#Rf-T-return)。

##### 强制实施

* 【简单】 当对并非 `owner` 的原始指针进行 `delete` 就发出警告。
* 【简单】 当任何代码路径上遗漏了对 `owner` 指针的 `reset` 或者显式的 `delete` 时就发出警告。
* 【简单】 当把 `new` 或者返回值为指针类型的函数的返回值赋值给原始指针时就发出警告。

### <a name="Ri-nullptr"></a>I.12: 把不能为空的指针声明为 `not_null`

##### 理由

帮助避免对 `nullptr` 解引用的错误。通过避免多余的 `nullptr` 检查来提高性能。

##### 示例

    int length(const char* p);            // 不清楚 length(nullptr) 是否有效

    length(nullptr);                      // OK?

    int length(not_null<const char*> p);  // 有改善：可以假定 p 不可能为 nullptr

    int length(const char* p);            // 只好假定 p 可以为 nullptr

通过在源代码中说明意图，实现者和工具就可以提供更好的诊断能力，比如通过静态分析来找出某些种类的错误，还可以实施优化，比如移除分支和空值测试。

##### 注解

指向 `char` 的指针将指向 C 风格的字符串（以零终结的字符的连续串）这一点仍然是潜规则，并且也是混乱和错误的潜在来源。请使用 `zstring` 来代替 `const char*`。

    int length(not_null<zstring> p);   // 可以假定 p 不能为 nullptr
                                       // 可以假定 p 指向以零终结的字符数组

注意： `length()` 显然是经过伪装的 `std::strlen()`。

##### 强制实施

* 【简单】〔基础〕 如果有函数在所有控制流路径上访问指针参数之前检查它是否是 `nullptr`，则给出警告称其应当被声明为 `not_null`。
* 【复杂】 如果有指针返回值的函数在所有返回路径上都保证其不是 `nullptr`，则给出警告称返回类型应当被声明为 `not_null`。

### <a name="Ri-array"></a>I.13: 不要只用一个指针来传递数组

##### 理由

 (pointer, size) 式的接口是易于出错的。同样，（指向数组的）普通指针还必须依赖某种约定以使被调用方来确定其大小。

##### 示例

考虑：

    void copy_n(const T* p, T* q, int n); // 从 [p:p+n) 复制到 [q:q+n)

当由 `q` 所指向的数组少于 `n` 个元素会怎么样？此时我们将覆写一些可能无关的内存。
当由 `p` 所指向的数组少于 `n` 个元素会怎么样？此时我们将读取一些可能无关的内存。
次二者都是未定义的行为，而且可能是非常恶劣的 BUG。

##### 替代方案

考虑使用明确的 `span`：

    void copy(span<const T> r, span<T> r2); // 将 r 复制给 r2

##### 示例，不好

考虑：

    void draw(Shape* p, int n);  // 糟糕的接口；糟糕的代码
    Circle arr[10];
    // ...
    draw(arr, 10);

把 `10` 作为参数 `n` 传递可能是错误的：虽然最常见的约定是假定有 [`0`:`n`)，但这点并未不是明确的。更糟糕的是，`draw()` 的调用通过编译了：这里有一次从数组到指针的隐式转换（数组衰退），然后又进行了从 `Circle` 到 `Shape` 的另一次隐式转换。`draw()` 是不可能安全地迭代这个数组的：它无法知道元素的大小。

**替代方案**: 使用一个辅助类来确保元素的数量正确，并避免进行危险的隐式转换。例如：

    void draw2(span<Circle>);
    Circle arr[10];
    // ...
    draw2(span<Circle>(arr));  // 推断出元素的数量
    draw2(arr);    // 推断出元素的类型和数组大小

    void draw3(span<Shape>);
    draw3(arr);    // 错误: 无法将 Circle[10] 转换为 span<Shape>

这个 `draw2()` 传递了与 `draw()` 同样数量的信息，但明确指定了它接受的是 `Circle` 的范围。参见 ???.

**例外**: 使用 `zstring` 和 `czstring` 来表示 C 风格的以零终结字符串。
但这样做时，应当使用 (GSL)[#GSL] 中的 `string_span` 以避免范围错误。

##### 强制实施

* 【简单】〔边界〕 对任何依赖于从数组类型向指针类型的隐式转换的表达式给出警告。允许 zstring/czstring 指针类型的例外。
* 【简单】〔边界〕 对任何指针类型表达式进行且结果为指针类型的值的运算操作给出警告。允许 zstring/czstring 指针类型的例外。


### <a name="Ri-global-init"></a>I.22: 避免全局对象之间进行复杂的初始化

##### 理由

复杂的初始化可能导致未定义的执行顺序。

##### 示例

    // file1.c

    extern const X x;

    const Y y = f(x);   // 读取 x; 写入 y

    // file2.c

    extern const Y y;

    const X x = g(y);   // 读取 y; 写入 x

由于 `x` 和 `y` 是处于不同翻译单元之内的，调用 `f()` 和 `g()` 的顺序就是未定义的；
我们可能会访问到还未初始化的 `const` 对象。
这个特别的例子展示了，全局（命名空间作用域）对象的初始化顺序难题并不仅限于全局*变量*而已。

##### 注解

并发代码中的初始化顺序问题是更加难于处理的。
所以通常最好完全避免使用全局（命名空间作用域）的对象。

##### 强制实施

* 标记调用了非 `constexpr` 函数的全局初始化式
* 标记访问了 `extern` 对象的全局初始化式

### <a name="Ri-nargs"></a>I.23: 保持较少的函数参数数量

##### 理由

大量参数会带来更大的出现混乱的机会。大量传递参数与其他替代方案相比也通常是代价比较大的。

##### 示例

标准库的 `merge()` 函数达到了我们可以自如处理的界限

    template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2,
                         OutputIterator result, Compare comp);

其中有四个模板参数和留个函数参数。
为简化最常用和最简单的用法，比较器参数可以缺省使用 `<`：

    template<class InputIterator1, class InputIterator2, class OutputIterator>
    OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2,
                         OutputIterator result);

这实际上不会减低其整体复杂性，但它减少了对于许多使用者的表面复杂性。
为了真正地减少参数的数量，我们得把参数归拢到更高层的抽象之中：

    template<class InputRange1, class InputRange2, class OutputIterator>
    OutputIterator merge(InputRange1 r1, InputRange2 r2, OutputIterator result);

把参数成“批”进行组合是减少参数数量和增加进行检查的机会的一般性技巧。

##### 注解

多少参数算很多？四个已经不少了。
有些函数确实最好表现为四个独立的参数，但这样的函数并不多。

**替代方案**: 把参数归集为由意义的对象，然后（按值或按引用）传递这些对象。

**替代方案**: 利用默认实参或者重载来让最常见的调用方式可以用比较少的实参来进行。

##### 强制实施

* 当函数声明了两个类型相同的迭代器（也包括指针）而不是一个范围或视图，就给出警告。
* 【无法强制实施】 这是一条理念性的指导方针，进行直接的检查是不可行的。

### <a name="Ri-unrelated"></a>I.24: 避免出现相邻而无关的相同类型的参数

##### 理由

相同类型的相邻参数很容易被不小心互换掉。

##### 示例，不好

考虑：

    void copy_n(T* p, T* q, int n);  // 从 [p:p+n) 复制到 [q:q+n)

这是个 K&R C 风格接口的一种恶劣的变种。它导致很容易把“目标”和“来源”参数搞反。

可以在“来源”参数上使用 `const`：

    void copy_n(const T* p, T* q, int n);  // 从 [p:p+n) 复制到 [q:q+n)

##### 示例

当参数的顺序不重要时，不会造成问题：

    int max(int a, int b);

##### 替代方案

不要以指针来传递数组，而要传递用来表示一个范围的对象（比如一个 `span`）：

    void copy_n(span<const T> p, span<T> q);  // 从 p 复制到 q

##### 替代方案

定义一个结构体来作为参数类型，并依照各个参数来命名它的各字段：

    struct SystemParams {
        string config_file;
        string output_path;
        seconds timeout;
    };
    void initialize(SystemParams p);

这样做带来一种使其调用代码对于以后的读者变得明晰的倾向，因为这种参数
在调用点通常都要按名字来进行填充。

##### 强制实施

【简单】 当两个连续的参数具有相同的类型时就给出警告。

### <a name="Ri-abstract"></a>I.25: 优先以抽象类作为类层次的接口

##### 理由

抽象类要比带有状态的基类更倾向于保持稳定。

##### 示例，不好

你知道 `Shape` 总会冒出来的 :-)

    class Shape {  // 不好: 接口类中加载了数据
    public:
        Point center() const { return c; }
        virtual void draw() const;
        virtual void rotate(int);
        // ...
    private:
        Point c;
        vector<Point> outline;
        Color col;
    };

这将强制性要求每个派生类都要计算出一个中心点——即使这并不容易，而且这个中心点从不会被用到。相似地说，不是每个 `Shape` 都有一个 `Color`，而许多 `Shape` 也最好别用一个定义成一系列 `Point` 的轮廓来进行表示。抽象类就是为了防止人们编写这样的类而创造出来的：

    class Shape {    // 有改进: Shape 是一个纯接口
    public:
        virtual Point center() const = 0;   // 纯虚函数
        virtual void draw() const = 0;
        virtual void rotate(int) = 0;
        // ...
        // ... 没有数据成员 ...
    };

##### 强制实施

【简单】 如果指向 `C` 类的指针被赋值给一个指向 `C` 的基类的指针，而这个基类包含数据成员时，就给出警告。

### <a name="Ri-abi"></a>I.26: 当想要跨编译器的 ABI 时，使用一个 C 风格的语言子集

##### 理由

不同的编译器会实现不同的类的二进制布局，异常处理，函数名字，以及其他的实现细节。

**例外**: 你可以使用少量精心选择的高层次 C++ 类型来精心制造出一种接口。参见 ???。

**例外**: 在一些平台上正有公共的 ABI 兴起，这可以使你从更加苛刻的限制中摆脱出来。

##### 注解

如果你只用一种编译器，你也可以在接口上使用完全的 C++。但当升级到新的编译器版本之后，可能需要进行重新编译。

##### 强制实施

【无法强制实施】 要可靠地识别某个接口是否是构成 ABI 的一部分是很困难的。

# <a name="S-functions"></a>F: 函数

函数指定了一个活动或者一次计算，以将系统从一种一致的状态转移到另一种一致的状态。函数是程序的基础构造块。

应当使函数的名字有意义，说明对其参数的必要条件，并清晰地规定参数和其结果之间的关系。函数的实现本身并不是规格说明。请尝试同时对函数应当做什么和函数应当怎样做来进行思考。
函数在大多数接口中都是最关键的部分，请参考接口的规则。

函数规则概览：

函数定义式的规则：

* [F.1: 把有意义的操作“打包”成为精心命名的函数](#Rf-package)
* [F.2: 一个函数应当实施单一一项逻辑操作](#Rf-logical)
* [F.3: 保持函数短小简洁](#Rf-single)
* [F.4: 如果函数必须在编译期进行求值，就将其声明为 `constexpr`](#Rf-constexpr)
* [F.5: 如果函数非常小，并且是时间敏感的，就将其声明为 `inline`](#Rf-inline)
* [F.6: 如果函数不会抛出异常，就将其声明为 `noexcept`](#Rf-noexcept)
* [F.7: 对于常规用法，应当接受 `T*` 或 `T&` 参数而不是智能指针](#Rf-smart)
* [F.8: 优先采用纯函数](#Rf-pure)

参数传递表达式的规则：

* [F.15: 优先采用简单的和传统的信息传递方式](#Rf-conventional)
* [F.16: 对于“输入（in）”参数，把复制操作廉价的类型按值进行传递，把其他类型按 `const` 引用进行传递](#Rf-in)
* [F.17: 对于“输入/输出（in-out）”参数，按非 `const` 引用进行传递](#Rf-inout)
* [F.18: 对于“消耗（consume）”参数，按 `X&&` 进行传递并对参数 `std::move`](#Rf-consume)
* [F.19: 对于“转发（forward）”参数，按 `TP&&` 进行传递并只对参数 `std::forward`](#Rf-forward)
* [F.20: 对于“输出（out）”值，采用返回值优先于输出参数](#Rf-out)
* [F.21: 要返回多个“输出”值，优先返回元组（tuple）或结构体](#Rf-out-multi)
* [F.60: 当“没有参数”是有效的选项时，采用 `T*` 优先于 `T&`](#Rf-ptr-ref)

参数传递语义的规则：

* [F.22: 用 `T*`，`owner<T*>` 或者智能指针来代表一个对象](#Rf-ptr)
* [F.23: 用 `not_null<T>` 来表明“空值（null）”不是有效的值](#Rf-nullptr)
* [F.24: 用 `span<T>` 或者 `span_p<T>` 来代表一个半开序列](#Rf-range)
* [F.25: 用 `zstring` 或者 `not_null<zstring>` 来代表 C 风格的字符串](#Rf-string)
* [F.26: 当需要指针时，用 `unique_ptr<T>` 来传递所有权](#Rf-unique_ptr)
* [F.27: 用 `shared_ptr<T>` 来共享所有权](#Rf-shared_ptr)

值返回语义的规则：

* [F.42: 返回 `T*` 来（仅仅）给出一个位置](#Rf-return-ptr)
* [F.43: 不要（直接或间接）返回指向局部对象的指针](#Rf-dangle)
* [F.44: 当不想进行复制，而“没有对象被返回”不是有效的选项时，返回 `T&`](#Rf-return-ref)
* [F.45: 不要返回 `T&&`](#Rf-return-ref-ref)
* [F.46: `int` 是 `main()` 的返回类型](#Rf-main)
* [F.47: 赋值运算符返回 `T&`](#Rf-assignment-op)

其他函数规则：

* [F.50: 当函数不适用时（不能俘获局部变量，或者不能编写局部函数），就使用 Lambda](#Rf-capture-vs-overload)
* [F.51: 如果需要作出选择，采用默认实参应当优先于进行重载](#Rf-default-args)
* [F.52: 对于局部使用的（也包括传递给算法的）lambda，优先采用按引用俘获](#Rf-reference-capture)
* [F.53: 对于非局部使用的（包括被返回的，在堆上存储的，或者传递给别的线程的）lambda，避免采用按引用俘获](#Rf-value-capture)
* [F.54: 当俘获了 `this` 时，显式俘获所有的变量（不使用默认俘获）](#Rf-this-capture)

函数和 Lambda 表达式以及函数对象有很强的相似性，请参见章节 ???。

## <a name="SS-fct-def"></a>F.def: 函数的定义式

函数的定义式就是一并指定了函数的实现（函数体）的函数声明式。

### <a name="Rf-package"></a>F.1: 把有意义的操作“打包”成为精心命名的函数

##### 理由

把公共的代码分解出去，将使代码更易于阅读，更可能被重用，并能够对源于复杂代码的错误有所限制。
如果某部分是一个明确指定的活动，就将之从其包围代码中分离出来，并为其进行命名。

##### 示例，请勿这样做

    void read_and_print(istream& is)    // 读取并打印一个 int
    {
        int x;
        if (is >> x)
            cout << "the int is " << x << '\n';
        else
            cerr << "no int on input\n";
    }

`read_and_print` 的几乎每件事都有问题。
它进行了读取，它（向一个固定 `ostream`）进行了写入，它（向一个固定的 `ostream`）写入了错误消息，它只能处理 `int`。
这里没有可以重用的东西，逻辑上分开的操作被搅拌到了一起，而局部变量在其逻辑上使用完毕之后仍处于作用域中。
作为一个小例子的话还好，但如果输入操作、输出操作和错误处理更加复杂的话，
这个纠缠混乱的代码就会变得难于理解了。

##### 注解

如果你编写的一个有些价值的 lambda 可能潜在地被用于多处，那就为它进行命名并将其赋值给一个（通常非局部的）变量。

##### 示例

    sort(a, b, [](T x, T y) { return x.rank() < y.rank() && x.value() < y.value(); });

对 lambda 进行命名，将会把这个表达式进行逻辑上的分解，还会为 lambda 的含义给出有力的提示。

    auto lessT = [](T x, T y) { return x.rank() < y.rank() && x.value() < y.value(); };

    sort(a, b, lessT);
    find_if(a, b, lessT);

对于性能和可维护性来说，最简短的代码并不总是最好的选择。

**例外**: 循环体，包括用作循环体的 lambda，很少需要进行命名。
然而，大型的循环体（比如好多行或者好多页）也是个问题。
规则“[保持函数短小简洁](#Rf-single)”暗含有“保持循环体短小”。
与此相似，用作回调参数的 lambda 有事后也是有意义的，虽然它们不大可能被重用。

##### 强制实施

* 参见“[保持函数短小简洁](#Rf-single)”
* 把不同地方所用的同样和非常相似的 lambda 标记出来。

### <a name="Rf-logical"></a>F.2: 一个函数应当实施单一一项逻辑操作

##### 理由

仅实施单一操作的函数易于理解，测试和重用。

##### 示例

考虑：

    void read_and_print()    // 不好
    {
        int x;
        cin >> x;
        // 检查错误
        cout << x << "\n";
    }

这是一整块被绑定到一个特定的输入的代码，而且无法为其找到另一种（不同的）用途。作为代替，我们把函数分解为合适的逻辑部分并进行参数化：

    int read(istream& is)    // 有改进
    {
        int x;
        is >> x;
        // 检查错误
        return x;
    }

    void print(ostream& os, int x)
    {
        os << x << "\n";
    }

这样的话，就可以在需要时进行组合：

    void read_and_print()
    {
        auto x = read(cin);
        print(cout, x);
    }

如果有需要，我们还可以进一步把 `read()` 和 `print()` 针对数据类型，I/O 机制，以及对错误的反应等等方面进行模板化。例如：

    auto read = [](auto& input, auto& value)    // 有改善
    {
        input >> value;
        // 检查错误
    };

    auto print(auto& output, const auto& value)
    {
        output << value << "\n";
    }

##### 强制实施

* 把具有多个“输出”参数的函数当作有问题的。使用返回值来代替，包括以 `tuple` 用作多个返回值。
* 把无法装入编辑器的一屏之内的“大型”函数当作有问题的。考虑把这种函数分解为较小的恰当命名的子操作。
* 把有七个或更多参数的函数当作有问题的。

### <a name="Rf-single"></a>F.3: 保持函数短小简洁

##### 理由

大型函数难于阅读，更有可能包含复杂的代码，而且更有可能含有其作用域超过最低限度的变量。
带有复杂的控制结构的函数更有可能变长，也更有可能隐藏逻辑错误于其中。

##### 示例

考虑：

    double simpleFunc(double val, int flag1, int flag2)
        // simpleFunc: 接受一个值并计算所需的 ASIC 值，依赖于两个模式标记。
    {

        double intermediate;
        if (flag1 > 0) {
            intermediate = func1(val);
            if (flag2 % 2)
                 intermediate = sqrt(intermediate);
        }
        else if (flag1 == -1) {
            intermediate = func1(-val);
            if (flag2 % 2)
                 intermediate = sqrt(-intermediate);
            flag1 = -flag1;
        }
        if (abs(flag2) > 10) {
            intermediate = func2(intermediate);
        }
        switch (flag2 / 10) {
            case 1: if (flag1 == -1) return finalize(intermediate, 1.171); break;
            case 2: return finalize(intermediate, 13.1);
            default: ;
        }
        return finalize(intermediate, 0.);
    }

这个函数过于复杂了（也相当长）。
要如何判断是否所有的可能性都被正确处理了呢？
当然，它也同样违反了别的规则。

我们可以进行重构：

    double func1_muon(double val, int flag)
    {
        // ???
    }

    double funct1_tau(double val, int flag1, int flag2)
    {
        // ???
    }

    double simpleFunc(double val, int flag1, int flag2)
        // simpleFunc: 接受一个值并计算所需的 ASIC 值，依赖于两个模式标记。
    {
        if (flag1 > 0)
            return func1_muon(val, flag2);
        if (flag1 == -1)
            return func1_tau(-val, flag1, flag2);    // 由 func1_tau 来处理: flag1 = -flag1;
        return 0.;
    }

##### 注解

“无法放入一屏显示”通常是对“太长了”的一种不错的实际定义方式。
一行到五行大小的函数应当被当作是常态。

##### 注解

把大型函数分解成较小的紧致的有名字的函数。
小型的简单函数在函数调用的代价比较明显时很容易被内联。

##### 强制实施

* 标记无法“放入一屏”的函数。
  一屏有多大？可以试试 60 行，每行 140 个字符；这大致上就是书本页面能够适于阅读的最大值了。
* 标记过于复杂的函数。多复杂算是过于复杂呢？
  应当用圈复杂度来度量。可以试试“多于 10 个逻辑路径”。一个简单的开关算作一条路径。

### <a name="Rf-constexpr"></a>F.4: 如果函数必须在编译期进行求值，就将其声明为 `constexpr`

##### 理由

需要用 `constexpr` 来告诉编译器允许对其进行编译期求值。

##### 示例

（不）著名的阶乘例子：

    constexpr int fac(int n)
    {
        constexpr int max_exp = 17;      // constexpr 让其可以在 Expects 中使用
        Expects(0 <= n && n < max_exp);  // 防止犯糊涂和发生溢出
        int x = 1;
        for (int i = 2; i <= n; ++i) x *= i;
        return x;
    }

这个是 C++14。对于 C++11，请使用递归形态的 `fac()`。

##### 注解

`constexpr` 并不会保证发生编译期求值；
它只能保证函数可以在当程序员需要或者编译器为优化而决定时，对常量表达式实参进行编译期求值。

    constexpr int min(int x, int y) { return x < y ? x : y; }

    void test(int v)
    {
        int m1 = min(-1, 2);            // 可能进行编译期求值
        constexpr int m2 = min(-1, 2);  // 编译期求值
        int m3 = min(-1, v);            // 运行期求值
        constexpr int m4 = min(-1, v);  // 错误: 无法在编译期求值
    }

##### 注解

`constexpr` 函数都是纯函数：它们不能有副作用。

    int dcount = 0;
    constexpr int double(int v)
    {
        ++dcount;   // 错误：试图在 constexpr 函数中产生副作用
        return v + v;
    }

通常这样是很棒的。

##### 注解

不要试图让所有函数都变成 `constexpr`。大多数计算都最好在运行时进行。

##### 注解

任何可能最终将依赖于高层次的运行时配置或者
业务逻辑的API，都不应当是 `constexpr` 的。这种定制化是无法
由编译期来求值的，并且依赖于这种 API 的任何 `constexpr` 函数
也都应当进行重构，或者抛弃掉 `constexpr`。

##### 强制实施

不可能也不必要。
当在要求常量的地方调用了非 `constexpr` 函数时，编译器会报告错误。

### <a name="Rf-inline"></a>F.5: 如果函数非常小，并且是时间敏感的，就将其声明为 `inline`

##### 理由

有些优化器可以不依赖于程序员的提示就能很好地进行内联，但请不要依赖这点。
请测量！至少超过 40 年，我们一直在允诺编译器可以不依赖于人类的提示而做到比人类更好地内联。
可是我们还在等。
给出 `inline` 能够促进编译器更好地工作。

##### 示例

    ???

**例外**: 不要把 `inline` 函数加入需要变得稳定的接口中，除非你十分确定它不会再发生变化。
内联函数是 ABI的一部分。

##### 注解

`constexpr` 蕴含 `inline`。

##### 注解

在类之中所定义的成员函数默认是 `inline` 的。

**例外**: 模板函数（包括模板成员函数）必须处于头文件中，因此是内联的。

##### 强制实施

对超过三条语句，并且本可以声明为非内联的 `inline` 函数（比如类成员函数）标记为 `inline`。
修正：将函数声明为非内联的。（NM: 这当然是可以做到的，不过基于大小的测量可能会让人不快。）

### <a name="Rf-noexcept"></a>F.6: 如果函数不会抛出异常，就将其声明为 `noexcept`

##### 理由

如果不打算抛出异常的话，程序就会认为无法处理这种错误，并且应当尽早终止。把函数声明为 `noexcept` 对优化器有好处，因为其减少了可能的执行路径的数量。它也能使发生故障之后的退出动作有所加速。

##### 示例

给完全以 C 或者其他任何没有异常的语言编写的每个函数都标上 `noexcept`。
C++ 标准库隐含地对 C 标准库中的所有函数做了这件事。

##### 注解

`constexpr` 函数不会抛出异常，因此并不需要为它们使用 `noexcept`。

##### 示例

对能够抛出异常的函数也可以使用 `noexcept`：

    vector<string> collect(istream& is) noexcept
    {
        vector<string> res;
        for (string s; is >> s;)
            res.push_back(s);
        return res;
    }

如果 `collect()` 耗光了内存，程序就会崩溃。
除非这个程序特别精心编写成不会耗尽内存，否则这可能正是正确的方式；
`terminate()` 能够产生合适的错误日志信息（但当内存耗尽时是很难做出任何巧妙的事情的）。

##### 注解

当你想决定是否要给函数标上 `noexcept` 时，一定要特别
注意你的代码的执行环境，尤其是与抛出异常和内存分配
相关的情形。打算成为完全通用的代码（比如像
标准库和其他类似的工具代码），应当支持那些
有意义地处理了 `bad_alloc` 异常的执行环境。
不过，大多数程序和执行环境都不能有意义地
处理内存分配失败，而中止程序则是在这些情况中
应对分类失败的最干净和最简单的方式。如果已知
应用程序代码无法应对分配失败的话，对于即使
确实会进行分配的函数，添加 `noexcept` 也是适当的。

换一种方式来说：在大多数程序中，大多数函数都会抛出异常（比如说，
它们可能使用 `new`，调用会抛出异常的函数，或者使用通过抛出异常
来报告失败的库函数），因此请勿随意到处散布 `noexcept` 而不
考虑清楚是否有异常是可以被处理的。

`noexcept` 对于常用的，底层的函数是最有用处的（并且几乎
显然是正确的）。

##### 注解

析构函数，`swap` 函数，移动操作，以及默认构造函数不应当抛出异常。

##### 强制实施

* 标记不是 `noexcept`，而又不能抛出异常的函数。
* 标记抛出异常的 `swap`，`move`，析构函数，以及默认构造函数。

### <a name="Rf-smart"></a>F.7: 对于常规用法，应当接受 `T*` 或 `T&` 参数而不是智能指针

##### 理由

智能指针的传递会转移或者共享所有权，因此应当仅在有意要实现所有权语义时才能使用（参见 [R.30](#Rr-smartptrparam)）。
使用按智能指针传递方式把函数限制为只能服务于使用智能指针的调用方。
智能指针的传递（比如 `std::shared_ptr`）暗含了一些运行时成本。

##### 示例

    void f(int*);             // 接受任何的 int*
    void g(unique_ptr<int>);  // 只能接受你想转移所有权的 int
    void g(shared_ptr<int>);  // 只能接受你想共享所有权的 int

    void h(const unique_ptr<int>&);  // 不会改变所有权，但要求调用方对其具有特定的所有权。
    
    void h(int&);             // 接受任何的 int

##### 示例，不好

    // 被调用方
    void f(shared_ptr<widget>& w)
    {
        // ...
        use(*w); // w 的唯一使用点 -- 其生存期是完全未被涉及到的
        // ...
    };

进一步请参见 [R.30](#Rr-smartptrparam)。

##### 注解

悬挂指针是可以静态地找出来的，因此我们并不需要依靠资源管理功能来避免悬挂指针。

**参见**: [何时应当采用 `T*`，何时应当采用 `T&`](#Rf-ptr-ref)。

**参见**: [智能指针的使用](#Rr-summary-smartptrs)的相关讨论。

##### 强制实施

* 标记以下情况：智能指针类型（重载了 `operator->` 或 `operator*` 的类型）的参数，它是可复制的，但从没有被从函数体中复制/移动出来，或者它是可移动，但从没有被从函数体中移动出来，或者它被按值传递，但从未进行修改或者传递给进行修改的其他函数。这意味着其中并未使用所有权语义。

### <a name="Rf-pure"></a>F.8: 优先采用纯函数

##### 理由

纯函数更容易进行推导，有时候也更易于优化（甚至并行化），有时候还可以进行存储。

##### 示例

    template<class T>
    auto square(T t) { return t * t; }

##### 注解

`constexpr` 函数就是纯函数。

##### 强制实施

不可能进行强制实施。

## <a name="SS-call"></a>F.call: 参数传递

存在各种不同的向函数传递参数和返回值的方式。


### <a name="Rf-conventional"></a>F.15: 优先采用简单的和传统的信息传递方式

##### 理由

使用“与众不同和精巧”的技巧会带来意外，其他程序员的理解减慢，并促进 BUG 的发生。
如果你确实想要比常规技巧更好的优化，请进行测量以确保它真的有所提升，并为其写下文档/注释，因为这种提升可能无法移植。

下面的表格总结了以下 F.16-21 的各个指导方针中的建议。

![一般性参数传递表](./param-passing-normal.png "一般性参数传递")

![高级参数传递表](./param-passing-advanced.png "高级参数传递")



### <a name="Rf-in"></a>F.16: 对于“输入（in）”参数，把复制操作廉价的类型按值进行传递，把其他类型按 `const` 引用进行传递

##### 理由

既能让调用者了解函数不会修改其参数，也使得参数能够以右值初始化。

何谓“复制操作廉价”依赖于机器的架构，不过只有两三个机器字（Word）的类型（double，指针，引用等）一般最好按值传递。
当可以廉价复制时，没什么比得过进行复制的简单性和安全性，而且对于小型对象（最多两三个机器字）来说，也比按引用传递更快，因为它不需要在函数中进行一次额外的引用访问。

##### 示例

    void fct(const string& s);  // OK: 按 const 引用传递; 总是廉价的

    void fct2(string s);        // bad: 可能是昂贵的

    void fct(int x);          // OK: 无可比拟

    void fct2(const int& x);  // bad: fct2() 中的访问带来开销

（仅）对于高级的运用，如果你确实需要为“只当作输入”的参数的按右值传递进行优化的话：

* 如果函数需要无条件地从参数进行移动，那就按 `&&` 来接受参数。参见 [F.18](#Rf-consume)。
* 如果函数需要保留参数的一个副本，那就在按 `const&` 接受参数（对于左值）之外，
添加一个按 `&&` 传递参数（对于右值）的重载，并在函数体中将之 `std::move` 到其目标之中。基本上，这个重载是“消耗”者；参见 [F.18](#Rf-consume)。
* 在特殊情况中，比如有多个“输入+复制”的参数时，考虑采用完美转发。参见 [F.19](#Rf-forward)。

##### 示例

    int multiply(int, int); // 仅输入了 int，按值传递

    string& concatenate(string&, const string& suffix); // suffix 仅作输入，但并不如 int 那样廉价，因此按 const& 传递

    void sink(unique_ptr<widget>);  // 仅作输入，但消耗了这个 widget

避免以下这类的“玄奥技巧”：

* “为了效率”而按 `T&&` 来传递参数。
关于按 `&&` 传递带来性能好处的大多数传言都是假的或者是脆弱的（不过也请参考 [F.25](#Rf-pass-ref-move)）。
* 从赋值或相似的操作中返回 `const T&`（参见 [F.47](#Rf-assignment-op)）。

##### 示例

假设 `Matrix` 带有移动操作（可能它将其元素都保存在一个 `std::vector` 中）：

    Matrix operator+(const Matrix& a, const Matrix& b)
    {
        Matrix res;
        // ... 用二者的和填充 res ...
        return res;
    }

    Matrix x = m1 + m2;  // 移动构造函数

    y = m3 + m3;         // 移动赋值

##### 注解

返回值优化无法处理赋值的情况，不过移动赋值却可以。

引用是被假定为指代某个有效对象的（语言规则）。
“空引用”（正规地说）是不存在的。
如果要表示一个非强制的值，请使用指针，`std::optional`，或者一个用以代表“没有值”的特殊值。

##### 强制实施
* 【简单】〔基础〕 当按值传递的参数的大小大于 `4 * sizeof(int)` 时给出警告。
  建议代之以指向 `const` 的引用。
* 【简单】〔基础〕 当按引用传递的 `const` 参数的大小小于 `3 * sizeof(int)` 时给出警告。建议代之以按值传递。
* 【简单】〔基础〕 当按引用传递的 `const` 参数被 `move` 时给出警告。


### <a name="Rf-inout"></a>F.17: 对于“输入/输出（in-out）”参数，按非 `const` 引用进行传递

##### 理由

让调用者明了这个对象假定将会被改动。

##### 示例

    void update(Record& r);  // 假定 update 将会写入 r

##### 注解

`T&` 参数既可以向函数中传递信息，也可以传递出来。
因此 `T&` 能够作为“输入/输出”参数。这点本身就可能是一种错误的来源：

    void f(string& s)
    {
        s = "New York";  // 不明显的错误
    }

    void g()
    {
        string buffer = ".................................";
        f(buffer);
        // ...
    }

这里，`g()` 的作者提供了一个缓冲区让 `f()` 来填充，但 `f()` 仅仅替换掉了它（以多少比简单的字符复制高一些的成本）。
如果 `g()` 的作者对 `buffer` 的大小作出了假设，那么就会发生糟糕的逻辑错误。

##### 强制实施
* 【中等】〔基础〕 对带有指向非 `const` 的引用参数但又*不*向其进行写入的函数给出警告。
* 【简单】〔基础〕 当按引用传递的非 `const` 参数被进行 `move` 时给出引用。


### <a name="Rf-consume"></a>F.18: 对于“消耗（consume）”参数，按 `X&&` 进行传递并对参数 `std::move`

##### 理由

这样做很高效，并且消除了调用点的 BUG：`X&&` 绑定到右值，而要传递左值的话则要求在调用点明确进行 `std::move`。

##### 示例

    ???
    
##### 例外

只能移动并且移动廉价的唯一拥有者类型，比如 `unique_ptr`，也可以按值传递，这样写起来更简单而且效果相同。按值传递确实产生了一次额外的（廉价）移动操作，但我们更加优先于简单性和清晰性。

##### 强制实施
* 对于所有 `X&&` 参数（其中的 `X` 不是模板类型参数的名字），如果函数体中使用它时没有用 `std::move`，就将其标明。
* 标明对已经被移动过的对象的访问。
* 不要有条件地从对象进行移动。


### <a name="Rf-forward"></a>F.19: 对于“转发（forward）”参数，按 `TP&&` 进行传递并只对参数 `std::forward`

##### 理由

如果一个对象要被传递给其他代码而并不在本函数中直接使用，我们就想让这个函数对于该参数的 `const` 性质和右值性质来说是中立的。

这种情况下，而且只有这种情况下，才应当让参数为 `TP&&`，其中 `TP` 为模板类型参数——它既*忽略*了也*保持*了 `const` 性质和右值性质。因而使用 `TP&&` 的任何代码都隐含地声称它自己并不关心变量的 `const` 性质和右值性质（因为这被忽略了），但它有意把值继续传递给其他确实关心 `const` 性质和右值性质的代码（因为这也是被保持的）。把 `TP&&` 用于参数类型上是安全的，因为从调用方传递来的任何临时对象都会在函数调用期间一直存活。基本上 `TP&&` 类型的参数应当总是在函数体中通过 `std::forward` 来继续传递。

##### 示例

    template <class F, class... Args>
    inline auto invoke(F f, Args&&... args) {
        return f(forward<Args>(args)...);
    }

    ??? calls ???

##### 强制实施
* 对于接受 `TP&&` 参数的函数（其中的 `TP` 不是模板类型参数的名字），如果函数对它做了任何别的事，而不是在每个静态路径中都正好进行一次 `std::forward`，就将函数进行标明。


### <a name="Rf-out"></a>F.20: 对于“输出（out）”值，采用返回值优先于输出参数

##### 理由

返回值是自我说明的，而 `&` 参数则既可能是输入/输出的也可能是仅输出的，并且倾向于被误用。

适用的情况也包括如标准容器这样的大型对象，它们为性能因素使用了隐式的移动操作，并且避免进行显式的内存管理。

当有多个值要返回时，[使用元组](#Rf-out-multi)或者类似的多成员类型。

##### 示例

    vector<const int*> find_all(const vector<int>&, int x);  // OK: 返回指向具有 x 值的元素的指针

    void find_all(const vector<int>&, vector<const int*>& out, int x);  // 不好: 把指向具有 x 值的元素的指针放入 out

##### 注解

含有许多（每个都廉价移动的）元素的结构体，聚合起来则可能是移动操作昂贵的。

不建议返回 `const` 值。这种老旧的建议已经过时了；它并不会带来什么价值，而且还会对移动语义造成影响。

    ??? example ???
    
##### 例外

* 对于非值类型，比如继承层次中的类型来说，可以用 `unique_ptr` 或 `shared_ptr` 来返回对象。
* 如果类型的移动操作昂贵（比如 `array<BigPOD>`），就考虑将其分配在自由存储中并返回一个句柄（比如 `unique_ptr`），或者传递一个指代用以填充的非 `const` 目标对象的引用（将其用作输出参数）。
* 对于允许调用方在内部循环中的多次函数调用之间重用自带容量的对象（比如 `std::string` 和 `std::vector`）的特殊情况，将对象按照输入/输出参数处理，并以 `&` 进行传递。这是对更通用的所谓“调用方分配输出”模式的一种用法。

##### 示例

    struct Package {      // 特殊情况: 移动操作昂贵的对象
        char header[16];
        char load[2024 - 16];
    };

    Package fill();       // 不好: 大型的返回值
    void fill(Package&);  // OK

    int val();            // OK
    void val(int&);       // 不好: val 会不会读取参数？

##### 强制实施
* 对于指代非 `const` 的引用参数，如果其被写入之前未进行过读取，而且其类型能够廉价地返回，则标记它们；它们应当是“输入”的返回值。
* 标记 `const` 返回值。修正方法：移除 `const` 使其变为返回非 `const` 值。


### <a name="Rf-out-multi"></a>F.21: 要返回多个“输出”值，优先返回元组（tuple）或结构体

##### 理由

返回值是自我说明为“仅输出”值的。
而且，C++ 是支持多返回值的，按约定使用的是 `tuple`，并在调用点可以使用特别方便的 `tie`。

##### 示例

    int f(const string& input, /*output only*/ string& output_data) // 不好: 在代码注释作用说明仅作输出的参数
    {
        // ...
        output_data = something();
        return status;
    }

    tuple<int, string> f(const string& input) // 好: 自我说明的
    {
        // ...
        return make_tuple(status, something());
    }

事实上，C++98 的标准库已经使用这种方便的功能了，因为 `pair` 就像一种两个元素的 `tuple` 一样。
例如，给定一个 `set<string> myset`，请考虑：

    // C++98
    result = myset.insert("Hello");
    if (result.second) do_something_with(result.first);    // 变通方案

在 C++11 中我们可以这样写，将结果直接放入现存的局部变量中：

    Sometype iter;                                          // 如果我们还未因为别的目的而使用
    Someothertype success;                                  // 这些变量，则进行默认初始化

    tie(iter, success) = myset.insert("Hello");         // 普通的返回值
    if (success) do_something_with(iter);

而在 C++17 中，我们可能可以写成这样，它同时对变量进行了声明：

    auto { iter, success } = myset.insert("Hello");
    if (success) do_something_with(iter);

**例外**: 对于像 `string` 和 `vector` 这样附带额外容量的类型来说，有时候使用“调用方分配的输出”模式来将它当作输入/输出参数会很有好处，
这是把一个仅作输出的对象按指代非 `const` 的引用来传递，使被调用方向对象写入时可以重用它已经包含的容量或者其他的资源。
对于重复调用其他函数来获得字符串值的循环来说，通过为整个循环使用单一一个字符串对象，这种技术可以显著地减少进行分配的次数。

    ??? example ???

##### 注解

一些情况下，返回某种像 `variant<T,error_code>` 这样的，用户定义的某个专门的 `Value_or_error` 类型，而不使用通用的 `tuple` 是有好处的。

##### 强制实施

* 输出参数应当被替换为返回值。
  输出参数时由函数写入的，调用了非 `const` 成员函数的，或者将它作为非 `const` 参数继续传递的参数。


### <a name="Rf-ptr"></a>F.22: 用 `T*`，`owner<T*>` 或者智能指针来代表一个对象

##### 理由

在传统的 C 和 C++ 代码中，普通的 `T*` 有各种互相没什么关联的用法，比如：

* 标识单个对象（本函数内不会进行 delete）
* 指向分配于自由存储之中的一个对象（随后将会 delete）
* 持有 `nullptr` 值
* 标识一个 C 风格字符串（以零结尾的字符数组）
* 标识一个数组，其长度被分开指明
* 标识数组中的一个位置

##### 示例

    void use(int* p, char* s, int* q)
    {
            *++p = 666;   // 不好: 不知道 p 是不是指向了两个元素；应当假定它并非如此，否则应当使用 span<int>
            cout << s;    // 不好: 不知道 s 指向的是不是以零结尾的字符数组；应当假定它并非如此，否则应当使用 zstring
            delete q;     // 不好: 不知道 *q 是不是在自由存储中分配的；应当假定它并非如此，否则应当使用 owner
    }

##### 注解

`owner<T*>` 表示所有权，`zstring` 表示 C 风格的字符串。

**再者**: 应当假定从指向 `T` 的智能指针（比如 `unique_ptr<T>`）中获得的 `T*`是指向单个元素的。

**参见**: [支持程序库](#S-gsl)。

##### 强制实施

* 【简单】〔边界〕 对指针类型的表达式的算术操作，若其结果为指针类型的值，就给出警告。

### <a name="Rf-nullptr"></a>F.23: 用 `not_null<T>` 来表明“空值（null）”不是有效的值

##### 理由

清晰性。以 `not_null<T>` 为参数的函数很明确地说明，应当由该函数的调用者来负责进行任何必须的 `nullptr` 检查。
相似地，以 `not_null<T>` 为返回值的函数很明确地说明，该函数的调用者无须检查 `nullptr`。

##### 示例

`not_null<T*>` 让读者（人类或机器）明了，在进行解引用前不需要检查 `nullptr`。
而且当进行调试时，可以对 `owner<T*>` 和 `not_null<T>` 进行植入来进行正确性检查。

考虑：

    int length(Record* p);

当调用 `length(p)` 时，我应该先测试 `p == nullptr` 吗？是不是应当由 `length()` 的实现来测试 `p == nullptr`？

    int length(not_null<Record*> p);  // 确保 p != nullptr 是调用者的任务

    int length(Record* p);            // length() 的实现者必须假定可能出现 p == nullptr

##### 注解

假定 `not_null<T*>` 不可能是 `nullptr`；而 `T*` 则可能为 `nullptr`；二者都可以在内存中表示为 `T*`（因此不会带来运行时开销）。

##### 注解

`not_null` 不仅对内建指针有效。它也能在 `unique_ptr`，`shared_ptr`，以及其他指针式的类型上使用。

##### 强制实施

* 【简单】 当函数中的一个原始指针在未测试 `nullptr`（或等价形式）之前就被解引用时，就给出警告。
* 【简单】 当函数中的一个原始指针有时候会在测试 `nullptr`（或等价形式）后进行解引用，而有时候不会时，就报错。
* 【简单】 当函数中的一个 `not_null` 指针进行了 `nullptr` 测试时，就给出警告。

### <a name="Rf-range"></a>F.24: 用 `span<T>` 或者 `span_p<T>` 来代表一个半开序列

##### 理由

非正式和不明确的范围（range）是一种错误来源。

##### 示例

    X* find(span<X> r, const X& v);    // 在 r 中寻找 v

    vector<X> vec;
    // ...
    auto p = find({vec.begin(), vec.end()}, X{});  // 在 vec 中寻找 X{}

##### 注解

范围（Range）在 C++ 代码中十分常见。典型情况下，它们都是隐含的，且非常难于保证它们能够被正确使用。
特别地，给定一对儿参数 `(p, n)` 来代表数组 [`p`:`p+n`)，
通常来说不可能确定 `*p` 后面是不是真的存在 `n` 个元素。
`span<T>` 和 `span_p<T>` 两个简单的辅助类，分别用于代表范围 [`p`:`q`)，以及一个以 `p` 开头并以使谓词为真的第一个元素结尾的范围。

##### 示例

`span` 代表元素的范围，我们应当如何操作范围的各个元素呢？

    void f(span<int> s)
    {
        for (int x : s) cout << x << '\n';  // 范围的遍历（保证正确进行）
        for (int i = 0; i<s.size(); ++i) cout << x << '\n';  // C 风格的遍历（可能带有检查）
        s[7] = 9;                           // 随机访问（可能带有检查）
        std::sort(&s[0],&s[s.size()/2]);    // 截取指针（可能带有检查）
    }
    
##### 注解

`span<T>` 对象并不拥有其元素，而且很小，可以按值传递。

把一个 `span` 对象作为参数传递的效率完全等同于传递一对儿指针参数或者传递一个指针和一个整数计数值。

**参见**: [支持程序库](#S-gsl)。

##### 强制实施

【复杂】 当对指针参数的访问是以其他整型类型的参数为边界限定时，就给出警告并建议改用 `span`。

### <a name="Rf-string"></a>F.25: 用 `zstring` 或者 `not_null<zstring>` 来代表 C 风格的字符串

##### 理由

C 风格的字符串非常普遍。它们是按一种约定方式定义的：就是以零结尾的字符数组。
我们必须把 C 风格的字符串从指向单个字符的指针或者指向字符数组的老式的指针当中区分出来。

##### 示例

考虑：

    int length(const char* p);

当调用 `length(s)` 时，我应该先测试 `s == nullptr` 吗？是不是应当由 `length()` 的实现来测试 `p == nullptr`？

    int length(zstring p);            // length() 的实现者必须假定可能出现 p == nullptr

    int length(not_null<zstring> p);  // it is the caller's job to make sure p != nullptr

##### 注解

`zstring` 不含有所有权。

**参见**: [支持程序库](#S-gsl)。


### <a name="Rf-unique_ptr"></a>F.26: 当需要指针时，用 `unique_ptr<T>` 来传递所有权

##### 理由

使用 `unique_ptr` 是安全地传递指针的最廉价的方式。

##### 示例

    unique_ptr<Shape> get_shape(istream& is)  // 从输入流中装配一个形状
    {
        auto kind = read_header(is); // 从输入中读取头部并识别下一个形状
        switch (kind) {
        case kCircle:
            return make_unique<Circle>(is);
        case kTriangle:
            return make_unique<Triangle>(is);
        // ...
        }
    }

##### 注解

当要传递的对象属于某个类层次，且将要通过接口（基类）来使用它时，你需要传递一个指针而不是对象。

##### 强制实施

【简单】 当函数返回了局部分配了的原始指针时就给出警告。建议改为使用 `unique_ptr` 或 `shared_ptr`。

### <a name="Rf-shared_ptr"></a>F.27: 用 `shared_ptr<T>` 来共享所有权

##### 理由

使用 `std::shared_ptr` 是表示共享所有权的标准方式。其含义是，最后一个拥有者负责删除对象。

##### 示例

    shared_ptr<const Image> im { read_image(somewhere) };

    std::thread t0 {shade, args0, top_left, im};
    std::thread t1 {shade, args1, top_right, im};
    std::thread t2 {shade, args2, bottom_left, im};
    std::thread t3 {shade, args3, bottom_right, im};

    // 分离各线程
    // 最后执行完的线程会删除这个图像

##### 注解

如果同时不可能超过一个所有者的话，优先采用 `unique_ptr` 而不是 `shared_ptr`。
`shared_ptr` 的作用是共享所有权。

注意，过于普遍的使用 `shared_ptr` 是有成本的（`shared_ptr` 的引用计数上的原子性操作会产生可测量的总体花费）。

##### 替代方案

让单个对象来拥有这个共享对象（比如一个有作用域的对象），并当其所有使用方都完成工作后（最好隐含地）销毁它。

##### 强制实施

【无法强制实施】 这种模式过于复杂，无法可靠地进行检测。


### <a name="Rf-ptr-ref"></a>F.60: 当“没有参数”是有效的选项时，采用 `T*` 优先于 `T&`

##### 理由

指针（`T*`）可能为 `nullptr`，而引用（`T&`）则不能，不存在合法的“空引用”。
有时候用 `nullptr` 作为一种代表“没有对象”的方式是有用处的，但若是没有这种情况的话，使用引用的写法更简单，而且可能会产生更好的代码。

##### 示例

    string zstring_to_string(zstring p) // zstring 就是 char*; 这是一个 C 风格的字符串
    {
        if (p==nullptr) return string{};    // p 可能为 nullptr; 别忘了要检查
        return string{p};
    }
    
    void print(const vector<int>& r)
    {
        // r 指代一个 vector<int>; 不需要检查
    }
    
##### 注解

构造出一个本质上是 `nullptr` 的引用是可能的，但不是合法的 C++ 代码（比如，`T* p = nullptr; T& r = (T&)*p;`）。
这种错误非常罕见。

##### 注解

如果你更喜欢指针写法（`->` 以及 `*` vs. `.`）的话，`not_null<T*>` 可以提供和 `T&` 相同的保证。

##### 强制实施

* Flag ???

### <a name="Rf-return-ptr"></a>F.42: 返回 `T*` 来（仅仅）给出一个位置

##### 理由

指针就是用来干这个的。
使用 `T*` 来传递所有权其实是一种误用。

##### 示例

    Node* find(Node* t, const string& s)  // 在 Node 组成的二叉树中寻找 s
    {
        if (t == nullptr || t->name == s) return t;
        if ((auto p = find(t->left, s))) return p;
        if ((auto p = find(t->right, s))) return p;
        return nullptr;
    }

`find` 所返回的指针如果不是 `nullptr` 的话，就指定了一个含有 `s` 的 `Node`。
重要的是，这里面并没有暗含着把所指向的对象的所有权传递给调用者。

##### 注解

迭代器、索引值和引用也可以用来传递位置。
[当不需要使用 `nullptr`](#Rf-ptr-ref)，或者[当不会改变被指代的对象](???)时，用引用通常比用指针更好。

##### 注解

不要返回指向某个不在调用方的作用域中的东西的指针；参见 [F.43](#Rf-dangle)。

##### 示例, 不好

    int* f()
    {
        int x = 7;
        // ...
        return &x;  // 不好: 返回了指向即将被销毁的对象的指针
    }

这点同样适用于引用：

    int& f()
    {
        int x = 7;
        // ...
        return x;  // 不好: 返回了指代即将被销毁的对象的引用
    }

**参见**: [有关如何避免悬挂指针的讨论](#???)。

##### 强制实施

这个问题的一种略微不同的变体，是把指针放入比它们所指向的对象存活期更长的容器之中。

* 编译器往往能识别出返回局部对象的引用的情况，而且许多情况下也能识别出返回指向局部对象的指针的情况。
* 静态代码分析可以识别出许多用指针来指定位置的常见模式（据此可以消除悬挂指针）。

### <a name="Rf-dangle"></a>F.43: 不要（直接或间接）返回指向局部对象的指针

##### 理由

避免由于使用了这种悬挂指针而造成的程序崩溃和数据损坏。

##### 示例, 不好

从函数返回后，其中的局部对象就不再存在了：

    int* f()
    {
        int fx = 9;
        return &fx;  // 不好
    }

    void g(int* p)   // 貌似确实是无辜的
    {
        int gx;
        cout << "*p == " << *p << '\n';
        *p = 999;
        cout << "gx == " << gx << '\n';
    }

    void h()
    {
        int* p = f();
        int z = *p;    // 从已经丢弃的栈帧中读取（不好）
        g(p);          // 把指向已丢弃栈帧的指针传递给函数（不好）
    }

我在一种流行的实现上得到了以下输出：

    *p == 999
    gx == 999

我预期这样的结果是因为，对 `g()` 的调用重用了被 `f()` 的调用所丢弃的栈空间，因此 `*p` 所指代的空间应当会被 `gx` 所占据。

请想象一下当 `fx` 和 `gx` 类型不同时会发生什么。
请想象一下当 `fx` 或 `gx` 的类型带有不变式时会发生什么。
请想象一下当在更大的一组函数之间传递的不止是悬挂指针时会发生什么。
请想象一下一个攻击者能够利用悬挂指针干些什么。

幸运的是，大多数（全部？）的当代编译器都可以识别这种简单的情况并给出警告。

##### 注解

用引用也可以构造出与此类似的例子。

##### 注解

这条仅适用于非 `static` 的局部变量。
所有的 `static` 变量都是（顾名思义）静态分配的，因此指向它们的指针不可能变为悬挂的。

##### 示例, 不好

并非所有的局部变量指针的泄漏都是那么明显的：

    int* glob;       // 全局变量的不好的方面太多了

    template<class T>
    void steal(T x)
    {
        glob = x();  // 不好
    }

    void f()
    {
        int i = 99;
        steal([&] { return &i; });
    }

    int main()
    {
        f();
        cout << *glob << '\n';
    }

我这次成功从 `f` 的调用所丢弃的位置上读到了数据。
存于 `glob` 中的指针可能在很晚才被使用，并可能以无法预测的方式造成各种麻烦。

##### 注解

局部变量的地址的“返回”或者泄漏方式，可能是返回语句，以 `T&` 输出参数，以所返回对象的成员，以所返回数组的元素，还有更多其他方式。

##### 注解

还可以构造出相似的从内部作用域“泄漏”到外部作用域的例子；
对这样的例子应当按照与从函数中泄漏指针的相同方式来处理。

**参见**: 另一种获得悬挂指针的方式是[指针失效](#???)。
这种情况也可以用相似的技术来检测和避免。

##### 强制实施

通过静态分析技术来避免。

### <a name="Rf-return-ref"></a>F.44: 当不想进行复制，而“没有对象被返回”不是有效的选项时，返回 `T&`

##### 理由

语言规则保证 `T&` 会指代对象，因此不需要对其测试 `nullptr`。

**参见**: 所返回的引用诀不能蕴含所有权的传递：
[有关如何避免悬挂指针的讨论](#???)以及[有关所有权的讨论](#???)。

##### 示例

    class car
    {
        array<wheel,4> w;
        // ...
    public:
        wheel& get_wheel(size_t i) { Expects(i<4); return w[i]; }
        // ...
    };
     
    void use()
    {
        car c;
        wheel& w0 = c.get_wheel(0); // w0 与 c 的生存期相同
    }
 
##### 强制实施

对不存在可能产生 `nullptr` 的 `return` 表达式的函数进行标记。

### <a name="Rf-return-ref-ref"></a>F.45: 不要返回 `T&&`

##### 理由

这会导致返回指代已销毁的临时对象的引用。`&&` 是临时对象的磁石。当把临时对象的引用*向下*传递给被调用方时是没有问题的，因为临时对象保证在函数调用之外存活。（参见 [F.24](#Rf-pass-ref-ref) 和 [F.25](#Rf-pass-ref-move)。）不过，当把这种引用*向上*传递给更大的调用方作用域时则是不好的。参见 ???。

对于（通过普通引用或者完美转发）传入参数并想要返回值的转发函数，请使用单纯的 `auto` 返回类型推断（而不是 `auto&&`）。

##### 示例, 不好

如果 `F` 按值返回的话，这个函数就返回了临时对象的引用。

    template<class F>
    auto&& wrapper(F f)
    {
        log_call(typeid(f)); // 或者别的什么测量手段
        return f();
    }

##### 示例, 好

更好的方式：

    template<class F>
    auto wrapper(F f)
    {
        log_call(typeid(f)); // 或者别的什么测量手段
        return f();
    }

**例外**: `std::move` 和 `std::forward` 确实会返回 `&&`，但它们只不过是强制转换 —— 只会按惯例在某些表达式上下文中使用，其中指代临时对象的引用只会在该临时对象呗销毁之前在同一个表达式中被传递。我们不知道还存在任何别的返回 `&&` 的好例子。

##### 强制实施

对除了 `std::move` 和 `std::forward` 之外的任何把 `&&` 作为返回类型的情况都进行标记。

### <a name="Rf-main"></a>F.46: `int` 是 `main()` 的返回类型

##### Reason

这是一条语言规则，但通常被“语言扩展”所违反，因此值得一提。
把 `main`（即程序中的那个全局的 `main`）声明为 `void` 会限制其可移植性。

##### 示例

        void main() { /* ... */ };  // 不好，不符合 C++

        int main()
        {
            std::cout << "This is the way to do it\n";
        }

##### 注解

我们提出这条规则，只是因为这种错误持续存在于大众之间。

##### 强制实施

* 编译器应当做到。
* 如果编译器做不到，就让工具把它标记出来。

### <a name="Rf-assignment-op"></a>F.47: 赋值运算符返回 `T&`

##### 理由

运算符重载的惯例（尤其是对于值类型来说），是让
`operator=(const T&)` 实施赋值之后返回（非 `const`）的
`*this`。这就确保了与标准库类型之间的一致性，并遵从了
“像 `int` 一样工作”的原则。

##### 注解

历史上层有过一些建议让赋值运算符返回 `const T&`。
这主要是为了避免 `(a=b)=c` 形式的代码 —— 这种代码其实并不常见到足以成为违反与标准类型之间一致性的理由。

##### 示例

        class Foo
        {
         public:
            ...
            Foo& operator=(const Foo& rhs) {
              // 复制各个成员。
              ...
              return *this;
            }
        };

##### 强制实施

应当通过工具对所有赋值运算符的返回类型（和返回值）进行检查
来强制实施。

### <a name="Rf-capture-vs-overload"></a>F.50: 当函数不适用时（不能俘获局部变量，或者不能编写局部函数），就使用 Lambda

##### 理由

函数是不能俘获局部变量或者在局部作用域中声明的；当想要这些能力时，如果可能就应当使用 lambda，不行的就用手写的函数对象。另一方面，lambda 和函数对象是不能重载的；如果想要重载，就优先使用函数（让 lambda 重载的变通方案相当繁复）。如果两种方式都不行的话，就优先写一个函数；应当只使用所需的最简工具。

##### 示例

    // 编写只会接受 int 或 string 的函数 -- 重载是很自然的
    void f(int);
    void f(const string&);

    // 编写需要俘获局部状态的函数对象，可以出现于
    // 语句或者表达式作用域中 -- lambda 更自然
    vector<work> v = lots_of_work();
    for (int tasknum = 0; tasknum < max; ++tasknum) {
        pool.run([=, &v]{
            /*
            ...
            ... 处理 v 的 1/max, 即第 tasknum 个部分
            ...
            */
        });
    }
    pool.join();

**例外**: 泛型的 lambda 可以提供一种更精简的编写函数模板的方式，因此会比较有用，虽然普通的函数模板用稍多一点儿的语法可以做到同样的事情。这种优势在未来一旦所有的函数都获得了 Concept 参数的能力之后就可能会消失。

##### 强制实施

* 有名字的非泛型 lambda（比如 `auto x = [](int i){ /*...*/; };`），而其并未发生俘获并且出现于全局作用域，对它们给出警告。代之以编写常规的函数。


### <a name="Rf-default-args"></a>F.51: 如果需要作出选择，采用默认实参应当优先于进行重载

##### 理由

默认实参本就是为一个单一实现提供替代的接口的。
无法保证一组重载函数全部都实现相同的语义。
使用默认实参可以避免出现代码重复。

##### 注解

当变化来自相同类型的一组参数时，需要在默认实参和重载两种方案之间进行选择。
例如：

    void print(const string& s, format f = {});

相对的则是

    void print(const string& s);  // 使用默认的 format
    void print(const string& s, format f);
    
如果要为一组不同类型来实现语义上等价的操作，就不需要进行选择了。例如：

    void print(const char&);
    void print(int);
    void print(zstring);
    
##### 参见

    [虚函数的默认实参](#Rf-virtual-default-arg}
    
##### 强制实施

    ???


### <a name="Rf-reference-capture"></a>F.52: 对于局部使用的（也包括传递给算法的）lambda，优先采用按引用俘获

##### 理由

为了效率和正确性，当使用局部的 lambda 时，你基本上总是需要进行按引用俘获。这也包括编写或者调用并行算法的情形，因为它们在返回前会进行联结。

##### 示例

下面是一个简单的三阶段并行管线。每个 `stage` 对象封装了一个工作线程和一个队列，有一个用来把任务入队的 `process` 函数，且其析构函数会自动进行阻塞以在线程结束前等待队列变空。

    void send_packets(buffers& bufs)
    {
        stage encryptor  ([] (buffer& b){ encrypt(b); });
        stage compressor ([&](buffer& b){ compress(b); encryptor.process(b); });
        stage decorator  ([&](buffer& b){ decorate(b); compressor.process(b); });
        for (auto& b : bufs) { decorator.process(b); }
    }  // 自动阻塞以等待管线完成

##### 强制实施

???

### <a name="Rf-value-capture"></a>F.53: 对于非局部使用的（包括被返回的，在堆上存储的，或者传递给别的线程的）lambda，避免采用按引用俘获

##### 理由

指向局部对象的指针和引用不能超出它们的作用域而存活。按引用捕获的 lambda 恰是另外一种保存指向局部对象的引用的地方，因而当它们（或其副本）存活超出作用域的话，也不应该这样做。

##### 示例

    {
        // ...

        // a, b, c 为局部变量
        background_thread.queue_work([=]{ process(a, b, c); });  // 需要 a, b, 和 c 的副本
    }

##### 强制实施

???

### <a name="Rf-this-capture"></a>F.54: 当俘获了 `this` 时，显式俘获所有的变量（不使用默认俘获）

##### 理由

这是容易混淆的。在成员函数里边写 `[=]` 貌似会按引用来俘获，但其实会按引用俘获数据成员，因为它实际上按值俘获了不可见的 `this` 指针。如果你确实要这样做的话，请把 `this` 写明。

##### 示例

    class myclass {
        int x = 0;
        // ...

        void f() {
            int i = 0;
            // ...

            auto lambda = [=]{ use(i,x); };   // 不好: “貌似”按复制/按值俘获
                // 注意:  [&] 在当前的语言规则下的语义是一样的，也会复制 this 指针
                //        [=,this] 和 [&,this] 也没好多少，并且也会导致混淆
            x = 42;
            lambda(); // 调用 use(42);
            x = 43;
            lambda(); // 调用 use(43);

            // ...

            auto lambda2 = [i,this]{ use(i,x); }; // ok, 最明确并且最不混淆

            // ...
        }
    };

##### 注解

这在标准化之中正在进行积极的讨论，而且很可能在未来版本的标准中通过增加一种新的俘获模式或者调整 `[=]` 的含义而得到结局。当前的话，还是应当明确为好。

##### 强制实施

* 对指定了默认俘获的 lambda 俘获列表并且还（无论显式还是通过默认俘获）俘获了 `this` 的情况进行标识。


# <a name="S-class"></a>C: 类和类层次

类是一种自定义类型，程序员可以定义它的表示，操作和接口。
类层次用于把相关的类组织到层次化的结构当中。

类的规则概览：

* [C.1: 把相关的数据组织到结构中（`struct` 或 `class`）](#Rc-org)
* [C.2: 当类具有不变式时使用 `class`；当数据成员可以独立进行变动时使用 `struct`](#Rc-struct)
* [C.3: 用类来表示接口和实现之间的区别](#Rc-interface)
* [C.4: 仅当函数直接访问类的内部表示时才让函数作为其成员](#Rc-member)
* [C.5: 把辅助函数放在其所支持的类相同的命名空间之中](#Rc-helper)
* [C.7: 不要在同一个语句中同时定义类或枚举并声明该类型的变量](#Rc-standalone)
* [C.8: 当有任何非公开成员时使用 `class` 而不是 `struct`](#Rc-class)
* [C.9: 让成员的暴露最小化](#Rc-private)

子章节：

* [C.concrete: 具体类型](#SS-concrete)
* [C.ctor: 构造函数，赋值和析构函数](#S-ctor)
* [C.con: 容器和其他资源包装](#SS-containers)
* [C.lambdas: 函数对象和 lambda](#SS-lambdas)
* [C.hier: 类层次（OOP）](#SS-hier)
* [C.over: 重载和运算符重载](#SS-overload)
* [C.union: 联合体](#SS-union)

### <a name="Rc-org"></a>C.1: 把相关的数据组织到结构中（`struct` 或 `class`）

##### 理由

易理解性。如果数据之间（以基本的原因而）相关，应当在代码中体现这点。

##### 示例

    void draw(int x, int y, int x2, int y2);  // 不好: 不必要的隐含式的关系
    void draw(Point from, Point to);          // 好多了

##### 注解

没有虚函数的简单的类是不会带来空间或时间开销的。

##### 注解

从语言的角度看，`class` 和 `struct` 的差别只有其成员的默认可见性不同。

##### 强制实施

也许不可能做到。也许对总是一起使用的数据项目进行启发式查找是一种可能方式。

### <a name="Rc-struct"></a>C.2: 当类具有不变式时使用 `class`；当数据成员可以独立进行变动时使用 `struct`

##### 理由

可读性。
易理解性。
`class` 的使用会提醒程序员需要考虑不变式。
这是一种很有用的惯例。

##### 注解

不变式是对象的成员之间的一种逻辑条件，必须由构造函数建立，并由公开成员函数假定成员。
不变式一旦建立（通常是由构造函数），就可以对对象的各个成员函数进行调用了。
不变式既可以非正式地说明（比如在代码注释中），也可以正式地用 `Expects` 说明。

如果数据成员都可以互相独立地进行改变，则不可能存在不变式。

##### 示例

    struct Pair {  // 成员可以独立地变动
        string name;
        int volume;
    };

但是：

    class Date {
    public:
        Date(int yy, Month mm, char dd);    // 验证 {yy, mm, dd} 是有效的日期并进行初始化
        // ...
    private:
        int y;
        Month m;
        char d;    // day
    };
    
##### 注解

如果一个类中有任何的 `private` 数据的话，其使用者就不可能不通过构造函数而完全初始化一个对象。
因此，类的定义者必然提供构造函数且必须明确其含义。
这就相当于表示该定义者需要定义一种不变式。

* 另见：[把带有私有数据的类定义为 `class`](#Rc-class)。
* 另见：[优先将接口部分放在类的开头](#Rl-order)。
* 另见：[使成员的暴露最小化](#Rc-private)。
* 另见：[避免 `protected` 数据](#Rh-protected)。

##### 强制实施

查找所有数据都私有的 `struct` 和带有公开成员的 `class`。

### <a name="Rc-interface"></a>C.3: 用类来表示接口和实现之间的区别

##### 理由

接口和实现之间的明确区别能够提升可读性并简化维护工作。

##### 示例

    class Date {
        // ... 一些内部表示 ...
    public:
        Date();
        Date(int yy, Month mm, char dd);    // 验证 {yy, mm, dd} 是有效的日期并进行初始化

        int day() const;
        Month month() const;
        // ...
    };

比如说，我们现在可以改变 `Date` 的表示而不对其使用者造成影响（虽然很可能需要重新编译）。

##### 注解

使用这样的类来表示接口和实现之间的区别当然不是唯一可能的方式。
比如说，我们也可以使用命名空间中的一组自由函数，一个抽象基类，或者一个带有概念的模板函数来表示一个接口。
最重要的一点，在于明确地把接口和其实现“细节”区分开来。
理想地，并且典型地，接口要比其实现稳定得多。

##### 强制实施

???

### <a name="Rc-member"></a>C.4: 仅当函数直接访问类的内部表示时才让函数作为其成员

##### 理由

比成员函数更少的耦合，减少可能由于改动对象状态而造成问题的函数，减少每当改变内部表示时需要进行修改的函数数量。

##### 示例

    class Date {
        // ... 相对较小的接口 ...
    };

    // 辅助函数:
    Date next_weekday(Date);
    bool operator==(Date, Date);

这些“辅助函数”并不需要直接访问 `Date` 的内部表示。

##### 注解

当 C++17 带来“统一函数调用”之后，这条规则会更有效。???

##### 强制实施

寻找并不直接访问数据成员的成员函数。
麻烦的是由许多并不需要直接访问数据成员的函数也会这么做。

### <a name="Rc-helper"></a>C.5: 把辅助函数放在其所支持的类相同的命名空间之中

##### 理由

辅助函数是（由类的作者提供的）并不需要直接访问类的内部表示的函数，它们也被当作是类的可用接口的一部分。
把它们和类放在相同的命名空间中，使它们与类的关系更明显，并允许通过基于参数的查找机制找到它们。

##### 示例

    namespace Chrono { // 我们在这里放置与时间有关的服务

        class Time { /* ... */ };
        class Date { /* ... */ };

        // 辅助函数:
        bool operator==(Date, Date);
        Date next_weekday(Date);
        // ...
    }
    
##### 注解

这点对于[重载运算符](#Ro-namespace)来说尤其重要。

##### 强制实施

* 对接受某一个命名空间中的参数类型的全局函数进行标记。


### <a name="Rc-standalone"></a>C.7: 不要在同一个语句中同时定义类或枚举并声明该类型的变量

##### 理由

在同一个声明式中混合类型的定义和另一个实体的定义会导致混淆，而且不是必要的。

##### 示例，不好

    struct Data { /*...*/ } data{ /*...*/ };

##### 示例，好

    struct Data { /*...*/ };
    Data data{ /*...*/ };

##### 强制实施

* 如果类或者枚举的定义式的 `}` 后面没有跟着 `;` 就标记出来。它缺少了 `;`。


### <a name="Rc-class"></a>C.8: 当有任何非公开成员时使用 `class` 而不是 `struct`

##### 理由

可读性。
表明有些东西被隐藏或者进行了抽象。
这是一种有用的惯例。

##### 示例，不好

    struct Date {
        int d,m;
 
        Date(int i, Month m);
        // ... 许多函数 ...
    private:
        int y;  // year
    };

这段代码在 C++ 语言规则方面没有任何问题，
但从设计角度看则几乎全是错误。
私有数据和公开数据相比藏得太远了。
数据在类的声明式中被分到了不同的部分中。
不同部分的数据具有不同的访问性。
所有这些都减弱了可读性，并使维护变得更复杂。


##### 注解

优先将接口部分放在类的开头[参见](#Rl-order)。

##### 强制实施

对于声明为 `struct` 的类，当其带有 `private` 或 `public` 成员时就进行标记。


### <a name="Rc-private"></a>C.9: 让成员的暴露最小化

##### 理由

封装。
信息隐藏。
使发生意外访问的机会最小化。
这会简化维护工作。

##### 示例

    ???

##### 注解

优先让 `public` 成员在前，`protected` 成员其次，`private` 成员在后[参见](#Rl-order)。

##### 强制实施

???

## <a name="SS-concrete"></a>C.concrete: 具体类型

类的理想情况，是成为一个正规类型。
其大致上的意思就是“表现为像 `int` 一样”。具体类型是一种最简单的类。
可以对正规类型的值进行复制，复制的结果是一个与原始对象具有相同的值的独立对象。
当一个具体类型同时具有 `=` 和 `==` 时，`a=b` 的结果应当导致 `a == b` 为 `true`。
也可以定义出没有赋值和相等运算符的具体类，但它们（应当）是罕见情况。
C++ 的内建类型都是正规的，标准库中的类，如 `string`，`vector` 和 `map` 等也同样如此。
具体类型也常被称为值类型，以便与继承层次中的类型之间进行区分。

具体类型的规则概览：

* [C.10: 优先使用具体类型而不是更复杂的类](#Rc-concrete)
* [C.11: 使具体类型正规化](#Rc-regular)

### <a name="Rc-concrete"></a>C.10 优先使用具体类型而不是更复杂的类

##### 理由

具体类型在本质上就比继承层次更简单：
它们更易于设计，更易于实现，更易于使用，更易于进行推理，更小，也更快。
使用继承层次是需要一些理由（用例）来支持的。

##### 示例

    class Point1 {
        int x, y;   
        // ... 一些操作 ...
        // ... 没有虚函数 ...
    };

    class Point2 {
        int x, y;
        // ... 一些操作，其中有些是虚的 ...
        virtual ~Point2();
    };

    void use()
    {
        Point1 p11 {1, 2};   // 在栈上创建一个对象
        Point1 p12 {p11};    // 一个副本

        auto p21 = make_unique<Point2>(1, 2);   // 在自由存储中创建一个对象
        auto p22 = p21.clone();                 // 创建一个副本
        // ...
    }

当一个类属于某个继承层次时，我们（即使在小例子中不需要，在真实代码中也）必然要通过指针或者引用来操作它的对象。
这意味着更多的内存开销，更多的分配和回收操作，以及更多的用于实施间接操作所带来的运行时开销。

##### 注解

具体类型可以在栈上分配，也可以成为其他类的成员。

##### 注解

对于运行时多态接口来说，使用间接是一项基本要求。
而分配/回收操作的开销则不是（它们只是最常见的情况而已）。
我们可以使用基类来作为有作用域的派生类对象的接口。
当禁止使用动态分配时（比如硬实时）就可以这样做，为某些种类的插件提供一种稳定的接口。

##### 强制实施

???

### <a name="Rc-regular"></a>C.11: 使具体类型正规化

##### 理由

正规类型比不正规的类型更易于理解和进行推导（不正规性会导致理解和使用上花费更多的精力）。

##### 示例

    struct Bundle {
        string name;
        vector<Record> vr;
    };

    bool operator==(const Bundle& a, const Bundle& b) { return a.name == b.name && a.vr == b.vr; }

    Bundle b1 { "my bundle", {r1, r2, r3}};
    Bundle b2 = b1;
    if (!(b1 == b2)) error("impossible!");
    b2.name = "the other bundle";
    if (b1 == b2) error("No!");

特别是，当具体类型带有赋值操作时，也应当为之提供相等运算符，以使得 `a=b` 蕴含 `a == b`。

##### 强制实施

???

## <a name="S-ctor"></a>C.ctor: 构造函数，赋值，和析构函数

这些函数控制对象的生存期：创建，复制，移动，以及销毁。
定义构造函数是为了确保以及简化类的初始化过程。

以下被称为*默认操作*：

* 默认构造函数: `X()`
* 复制构造函数: `X(const X&)`
* 复制赋值: `operator=(const X&)`
* 移动构造函数: `X(X&&)`
* 移动赋值: `operator=(X&&)`
* 析构函数: `~X()`

缺省情况下，编译器会为这些操作中被使用的进行定义，但这些默认定义可以被抑制掉。

默认造作是一组互相关联的操作，它们共同实现了对象的生存期语义。
缺省情况下，C++ 按照值类型的方式来对待各个类，但并非所有的乐行都与值类型相符。

默认操作的规则集合：

* [C.20: 只要可能，请避免定义任何的默认操作](#Rc-zero)
* [C.21: 如果对任何默认操作提供了定义或者 `=delete`，请为所有默认操作都提供定义或者 `=delete`](#Rc-five)
* [C.22: 使默认操作之间保持一致](#Rc-matched)

析构函数的规则：

* [C.30: 如果一个类需要在对象销毁时执行明确的操作，请为其定义析构函数](#Rc-dtor)
* [C.31: 类所获取的所有资源，必须都在类的析构函数中进行释放](#Rc-dtor-release)
* [C.32: 如果类中带有原始指针（`T*`）或者引用（`T&`），请考虑它是否是所有者](#Rc-dtor-ptr)
* [C.33: 如果类中带有所有权的指针成员，请定义析构函数或使之为 `=delete`](#Rc-dtor-ptr2)
* [C.34: 如果类中带有所有权的引用成员，请定义析构函数或使之为 `=delete`](#Rc-dtor-ref)
* [C.35: 带有虚函数的基类应当有虚析构函数](#Rc-dtor-virtual)
* [C.36: 析构函数不能失败](#Rc-dtor-fail)
* [C.37: 使析构函数 `noexcept`](#Rc-dtor-noexcept)

构造函数的规则：

* [C.40: 如果类具有不变式，请为其定义构造函数](#Rc-ctor)
* [C.41: 构造函数应当创建经过完整初始化的对象](#Rc-complete)
* [C.42: 当构造函数无法构造有效对象时，应当抛出异常](#Rc-throw)
* [C.43: 保证类带有默认构造函数](#Rc-default0)
* [C.44: 尽量让默认构造函数简单且不抛出异常](#Rc-default00)
* [C.45: 不要定义仅对数据成员进行初始化的默认构造函数；应当使用成员初始化式](#Rc-default)
* [C.46: 默认情况下，把单参数的构造函数声明为 `explicit`](#Rc-explicit)
* [C.47: 按成员声明的顺序对成员变量进行定义和初始化](#Rc-order)
* [C.48: 对于常量初始化式来说，优先采用类中的初始化式而不是构造函数中的成员初始化式](#Rc-in-class-initializer)
* [C.49: 在构造函数中，优先进行初始化而不是赋值](#Rc-initialize)
* [C.50: 当初始化过程中需要体现“虚函数行为”时，请使用工厂函数](#Rc-factory)
* [C.51: 用委派构造函数来表示类中所有构造函数的共同行为](#Rc-delegating)
* [C.52: 使用继承构造函数来把构造函数引入到无须进行其他的明确初始化操作的派生类之中](#Rc-inheriting)

复制和移动的规则：

* [C.60: 使复制赋值非 `virtual`，接受 `const&` 的参数，并返回非 `const` 的引用](#Rc-copy-assignment)
* [C.61: 复制操作应当进行复制](#Rc-copy-semantic)
* [C.62: 使复制赋值可以安全进行自赋值](#Rc-move-self)
* [C.63: 使移动赋值非 `virtual`，接受 `&&` 的参数，并返回非 `const` 的引用](#Rc-move-assignment)
* [C.64: 移动操作应当进行移动，并使原对象处于有效状态](#Rc-move-semantic)
* [C.65: 使移动赋值可以安全进行自赋值](#Rc-copy-self)
* [C.66: 使移动操作 `noexcept`](#Rc-move-noexcept)
* [C.67: 基类应当抑制赋值操作，并在需要复制能力时提供一个虚的 `clone` 函数](#Rc-copy-virtual)

其他的默认操作规则：

* [C.80: 当需要明确使用缺省语义时，使用 `=default`](#Rc-default)
* [C.81: 当需要关闭缺省行为（且不需要替代的行为）时，使用 `=delete`](#Rc-delete)
* [C.82: 不要在构造函数和析构函数中调用虚函数](#Rc-ctor-virtual)
* [C.83: 考虑为值类型提供 `noexcept` 的 `swap` 函数](#Rc-swap)
* [C.84: `swap` 不应当失败](#Rc-swap-fail)
* [C.85: 使 `swap` 函数 `noexcept`](#Rc-swap-noexcept)
* [C.86: 使 `==` 对操作数的类型对称，并使之 `noexcept`](#Rc-eq)
* [C.87: 请当心基类的 `==`](#Rc-eq-base)
* [C.89: 使 `hash` 函数 `noexcept`](#Rc-hash)

## <a name="SS-defop"></a>C.defop: 默认操作

缺省情况下，语言会提供具有预置语义的默认操作。
不过，程序员可以关闭或者替换掉这些缺省实现。

### <a name="Rc-zero"></a>C.20: 只要可能，请避免定义任何的默认操作

##### 理由

这样最简单，而且能提供最清晰的语义。

##### 示例

    struct Named_map {
    public:
        // ... 并未声明任何默认操作 ...
    private:
        string name;
        map<int, int> rep;
    };

    Named_map nm;        // 默认构造
    Named_map nm2 {nm};  // 复制构造

由于 `std::map` 和 `string` 都带有全部的特殊函数，这里并不需要做别的事情。

##### 注解

这被称为“零之准则（The rule of zero）”。

##### 强制实施

【无法强制实施】 虽然无法强制实施，但一个优秀的静态分析器可以检查出一些模式，指出可使之符合本条规则的改进可能性。
例如，一个带有（指针,大小）成员对，同时在析构函数中 `delete` 这个指针的类也许可以被转换为使用一个 `vector`。

### <a name="Rc-five"></a>C.21: 如果对任何默认操作提供了定义或者 `=delete`，请为所有默认操作都提供定义或者 `=delete`

##### 理由

特殊函数的语义互相之间是紧密相关的，一旦其中一个不能采用预置定义，其他的就也需要进行修改。

##### 示例，不好

    struct M2 {   // 不好: 不完整的默认操作集合
    public:
        // ...
        // ... 没有复制和移动操作 ...
        ~M2() { delete[] rep; }
    private:
        pair<int, int>* rep;  // pair 的以零终止的集合
    };

    void use()
    {
        M2 x;
        M2 y;
        // ...
        x = y;   // 缺省的赋值
        // ...
    }

既然对于析构函数需要“特殊关照”（这里是要进行回收操作），复制和移动赋值（它们都隐含地销毁对象）仍保持正确性的可能是很低的（此处会导致双重删除问题）。

##### 注解

这被称为“五之准则（The rule of five）”或“六之准则（The rule of six）”，区别是你是否把默认构造函数算入。

##### 注解

如果想保持默认操作的缺省实现（当定义了别的默认操作时），请写下 `=default` 以表明对这个函数是特意这样做的。
如果不想要一个默认操作，可以用 `=delete` 来抑制它。

##### 注解

编译期会很大程度上强制实施这条规则，并在理想情况下会对任何违反都给出警告。

##### 注解

在带有析构函数的类中，依靠隐式生成的复制操作的做法已经被摒弃。

##### 强制实施

【简单】 类中应当要么为每个特殊函数都提供一个声明（即便是 `=delete`），要么都不这样做。

### <a name="Rc-matched"></a>C.22: 使默认操作之间保持一致

##### 理由

默认操作是一个概念上向配合的集合。它们的语义是相互关联的。
如果复制/移动构造和复制/移动赋值所做的是逻辑上不同的事情的话，这会让使用者感觉诡异。如果构造函数和析构函数并不提供一种对资源管理的统一视角的话，也会让使用者感觉诡异。如果复制和移动操作并不体现出构造函数和析构函数的工作方式的话，同样会让使用者感觉诡异。

##### 示例，不好

    class Silly {   // 不好: 复制操作不一致
        class Impl {
            // ...
        };
        shared_ptr<Impl> p;
    public:
        Silly(const Silly& a) : p{a.p} { *p = *a.p; }   // 深复制
        Silly& operator=(const Silly& a) { p = a.p; }   // 浅复制
        // ...
    };

这些操作在复制语义上并不统一。这将会导致混乱和出现 BUG。

##### 强制实施

* 【复杂】 复制/移动构造函数和对应的复制/移动赋值运算符，应当在相同的解引用层次上向相同的成员变量进行写入。
* 【复杂】 在复制/移动构造函数中被写入的任何成员变量，在其他构造函数中也都应当进行初始化。
* 【复杂】 如果复制/移动构造函数对某个成员变量进行了深复制，就应当在析构函数中对这个成员变量进行修改。
* 【复杂】 如果析构函数修改了某个成员变量，在任何复制/移动构造函数或赋值运算符中就都应当对该成员变量进行写入。

## <a name="SS-dtor"></a>C.dtor: 析构函数

“这个类需要析构函数吗？”是一个出人意料强有力的设计问题。
对于大多数类来说，答案是“不需要”，要么是因为类中并没有保持任何资源，要么是因为销毁过程已经被[零之准则](#Rc-zero)处理掉了；
就是说，它的成员在销毁之中可以自己照顾自己。
当答案为“需要”时，类的大部分设计应当遵循下列规则（参见[五之准则](#Rc-five)）。

### <a name="Rc-dtor"></a>C.30: 如果一个类需要在对象销毁时执行明确的操作，请为其定义析构函数

##### 理由

析构函数是在对象的生存期结束时被隐式执行的。
如果预置的析构函数足堪使用的话，就应当用它。
只有当类需要执行的代码不在其成员的析构函数中时，才需要定义非预置的析构函数。

##### 示例

    template<typename A>
    struct final_action {   // 略有简化
        A act;
        final_action(A a) :act{a} {}
        ~final_action() { act(); }
    };

    template<typename A>
    final_action<A> finally(A act)   // 推断出动作的类型
    {
        return final_action<A>{act};
    }

    void test()
    {
        auto act = finally([]{ cout << "Exit test\n"; });  // 设置退出动作
        // ...
        if (something) return;   // 动作在这里得到执行
        // ...
    } // 动作在这里得到执行

`final_action` 的全部目的就是为了在其销毁时执行一段代码（通常是一个 lambda）。

##### 注解

需要自定义析构函数的类大致上有两种：

* 类中具有某个资源，而它并未表示成一个具有析构函数的类，比如 `vector` 或事物类。
* 类的目的主要用于在销毁时执行某个动作，比如一个追踪器，或者 `final_action`。

##### 示例，不好

    class Foo {   // 不好; 使用预置的析构函数
    public:
        // ...
        ~Foo() { s = ""; i = 0; vi.clear(); }  // 清理
    private:
        string s;
        int i;
        vector<int> vi;
    };

预置的析构函数会做得更好，更高效，而且不会出错。

##### 注解

当需要预置的析构函数，但其生成被抑制（比如由于定义了移动构造函数）时，可以使用 `=default`。

##### 强制实施

查找疑似“隐式的资源”，比如指针和引用等。查找带有析构函数的类，即便其所有数据成员都带有自己的析构函数。

### <a name="Rc-dtor-release"></a>C.31: 类所获取的所有资源，必须都在类的析构函数中进行释放

##### 理由

避免资源泄漏，尤其是错误情形中。

##### 注解

对于以具有完整的默认操作集合的类来表示的资源来说，这些都是会自动发生的。

##### 示例

    class X {
        ifstream f;   // 可能会拥有某个文件
        // ... 没有任何定义或者声明为 =deleted 的默认操作 ...
    };

`X` 的 `ifstream` 会在其所在 `X` 的销毁时，隐含地关闭任何可能已经被它所打开的文件。

##### 示例，不好

    class X2 {     // 不好
        FILE* f;   // 可能会拥有某个文件
        // ... 没有任何定义或者声明为 =deleted 的默认操作 ...
    };

`X2` 可能会泄漏文件的句柄。

##### 注解

不过关不掉的 socket 怎么办呢？析构函数、close 以及清理操作[不应当失败](#Rc-dtor-fail)。
如果它确实这样的话，就出现了一个不存在真正的好解决方案的问题。
对于生手来说，作为析构函数的编写者，无法了解析构函数是因为什么被调用的，而且不能通过抛出异常来“拒绝执行”。
参见[相关讨论](#Sd-never-fail)。
让这个问题更加糟糕的，还包括许多的 close/release 操作都是无法重试的。
许多人都曾试图解决这个问题，但仍不存在已知的一般性解决方案。
如果可能的话，可以考虑吧 close/cleanup 的失败看成是基本的设计错误，然后终止程序（terminate）。

##### 注解

类之中也可以持有指向它并不拥有的对象的指针和引用。
显然这样的对象是不应当在类的析构函数中被 `delete` 的。
例如：

    Preprocessor pp { /* ... */ };
    Parser p { pp, /* ... */ };
    Type_checker tc { p, /* ... */ };

这里的 `p` 指向 `pp` 但并不拥有它。

##### 强制实施

* 【简单】 当类中所有的指针或引用成员变量是所有者
  （比如通过使用 `gsl::owner` 所断定）时，它们就应当在析构函数中有所引用。
* 【困难】 当在所有权上没有明确的说法时，为指针或引用成员变量确定其是否是所有者
  （比如，检查构造函数的代码）。

### <a name="Rc-dtor-ptr"></a>C.32: 如果类中带有原始指针（`T*`）或者引用（`T&`），请考虑它是否是所有者

##### 理由

大量的代码都是和所有权无关的。

##### 示例

    ???

##### 注解

如果 `T*` 或 `T&` 是有所有权的，就将其标为 `owning`。如果 `T*` 没有所有权，考虑将其标为 `ptr`。
这将有助于文档和分析工作。

##### 强制实施

查看原始指针成员和引用成员的初始化，看看是否进行了分配操作。

### <a name="Rc-dtor-ptr2"></a>C.33: 如果类中带有所有权的指针成员，请定义析构函数

##### 理由

被拥有的对象，必须在拥有它的对象销毁时进行 `delete`。

##### 示例

指针成员可能表示某种资源。
[不应该这样使用 `T*`](#Rr-ptr)，但老代码中这是很常见的。
请把 `T*` 当作一种可能的所有者的嫌疑。

    template<typename T>
    class Smart_ptr {
        T* p;   // 不好: *p 的所有权含糊不清
        // ...
    public:
        // ... 没有自定义的默认操作 ...
    };

    void use(Smart_ptr<int> p1)
    {
        auto p2 = p1;   // 错误: p2.p 泄漏了（当其不为 nullptr 且未被其他代码所拥有时）
    }

注意，当你定义析构函数时，你必须定义或者弃置（delete）[所有的默认操作](#Rc-five)：

    template<typename T>
    class Smart_ptr2 {
        T* p;   // 不好: *p 的所有权含糊不清
        // ...
    public:
        // ... 没有自定义的复制操作 ...
        ~Smart_ptr2() { delete p; }  // p 是所有者！
    };

    void use(Smart_ptr<int> p1)
    {
        auto p2 = p1;   // 错误: 双重删除
    }

预置的复制操作仅仅把 `p1.p` 复制给了 `p2.p`，折导致对 `p1.p` 进行双重销毁。请明确所有权的处理：

    template<typename T>
    class Smart_ptr3 {
        owner<T>* p;   // OK: 明确了 *p 的所有权
        // ...
    public:
        // ...
        // ... 复制和移动操作 ...
        ~Smart_ptr3() { delete p; }
    };

    void use(Smart_ptr3<int> p1)
    {
        auto p2 = p1;   // 错误: 双重删除
    }

##### 注解

通常最简单的处理析构函数的方式，就是把指针换成一个智能指针（比如 `std::unique_ptr`），并让编译器来安排进行恰当的隐式销毁过程。

##### 注解

为什么不直接要求全部带有所有权的指针都是“智能指针”呢？
这样做有时候需要进行不平凡的代码改动，并且可能会对 ABI 造成影响。

##### 强制实施

* 怀疑带有指针数据成员的类。
* 带有 `owner<T>` 的类应当定义其默认操作。

### <a name="Rc-dtor-ref"></a>C.34: 如果类中带有所有权的引用成员，请定义析构函数

##### 理由

引用成员可能表示某种资源。
不应该这样做，但这在老代码中很常见。
参见[指针成员和析构函数](#Rc-dtor-ptr)。
而且，复制可能会导致发生切片。

##### 示例，不好

    class Handle {  // 十分可疑的类
        Shape& s;   // 使用引用而不是指针来避免重新绑定
                    // 不好: *p 的所有权含糊不清
        // ...
    public:
        Handle(Shape& ss) : s{ss} { /* ... */ }
        // ...
    };

是否应当由 `Handle` 负责其 `Shape` 的销毁的问题，与[指针的情况](#Rc-dtor-ptr)是一样的：
当 `Handle` 拥有由 `s` 所指代的对象时，它必须有一个析构函数。

##### 示例

    class Handle {        // OK
        owner<Shape&> s;  // 使用引用而不是指针来避免重新绑定
        // ...
    public:
        Handle(Shape& ss) : s{ss} { /* ... */ }
        ~Handle() { delete &s; }
        // ...
    };

无论 `Handle` 是否拥有 `Shape`，我们都必须考虑预置复制操作的嫌疑：

    Handle x {*new Circle{p1, 17}};  // Handle 最好拥有这个 Circle，否则会发生泄漏
    Handle y {*new Triangle{p1, p2, p3}};
    x = y;     // 预置的赋值将尝试执行 *x.s = *y.s

这个 `x=y` 相当可疑。
它把 `Triangle` 赋值给 `Circle` 吗？
除非 `Shape` 使其[复制赋值为 `=delete`](#Rc-copy-virtual)，否则将只有 `Triangle` 的 `Shape` 部分被复制到 `Circle` 之中。

##### 注解

为什么不直接要求全部带有所有权的引用都替换为“智能指针”呢？
把引用改为智能指针会导致代码改动。
我们（还）没有所谓智能引用。
而且，这也会对 ABI 造成影响。

##### 强制实施

* 怀疑带有引用数据成员的类。
* 带有 `owner<T>` 引用的类应当定义其默认操作。

### <a name="Rc-dtor-virtual"></a>C.35: 基类的析构函数应当要么是 public 和 virtual，要么是 protected 且非 virtual

##### 理由

以防止未定义行为。
若析构函数是 public，调用方代码就可以尝试通过基类指针来销毁一个派生类的对象，而如果基类的析构函数是非 virtual，则其结果是未定义的。
若析构函数是 protected，调用方代码就无法通过基类指针进行销毁，而且这个析构函数不需要是 virtual；它应当是 protected 而不是 private，以便它能够在派生类析构函数中执行。
总之，基类的编写者并不知道什么是当进行销毁时要做的适当操作。

##### 探讨

请参见[这条规则](#Sd-dtor)中的探讨段落.

##### 示例，不好

    struct Base {  // 不好: 没有虚析构函数
        virtual f();
    };

    struct D : Base {
        string s {"a resource needing cleanup"};
        ~D() { /* ... do some cleanup ... */ }
        // ...
    };

    void use()
    {
        unique_ptr<Base> p = make_unique<D>();
        // ...
    } // p 的销毁调用了 ~Base() 而不是 ~D()，这导致 D::s 的泄漏，也许不止

##### 注解

虚函数针对派生类定义了一个接口，使用它并不需要对派生类有所了解。
如果这个接口允许进行销毁，那么它应当安全地做到这点。

##### 注解

析构函数必须是非私有的，否则它会妨碍使用这个类型：

    class X {
        ~X();   // 私有析构函数
        // ...
    };

    void use()
    {
        X a;                        // 错误: 无法销毁
        auto p = make_unique<X>();  // 错误: 无法销毁
    }

##### 例外

可以构想出一种可能需要受保护虚析构函数的情形：派生类型（且仅限于这种类型）的对象允许通过基类指针来销毁*另一个*对象（而不是其自身）。不过我们在实际中从未见到过这种情况。

##### 强制实施

* 带有任何虚函数的类的析构函数，应当要么是 public virtual，要么是 protected 且非 virtual。


### <a name="Rc-dtor-fail"></a>C.36: 析构函数不能失败

##### 理由

一般来说当析构函数可能失败时我们不知道怎样写出没有错误的代码。
标准库要求它所处理的所有的类所带有的析构函数都应当不会因抛出异常而退出。

##### 示例

    class X {
    public:
        ~X() noexcept;
        // ...
    };

    X::~X() noexcept
    {
        // ...
        if (cannot_release_a_resource) terminate();
        // ...
    }

##### 注解

许多人都曾试图针对析构函数中的故障处理设计一种傻瓜式的方案。
但没有人得到过任何一种通用方案。
这确实是真正的实际问题：比如说，怎么处理无法关闭的 socket？
析构函数的编写者无法了解析构函数为什么会被调用，并且不能通过抛出异常来“拒绝执行”。
参见[探讨](#Sd-dtor)段落。
让问题更麻烦的是，许多的“关闭/释放”操作还都是不能重试的。
如果确实可行的话，请把“关闭/清理”的失败作为一项基本设计错误并终止（terminate）程序。

##### 注解

把析构函数声明为 `noexcept`。这将确保它要么正常完成执行，要么就终止程序。

##### 注解

如果一个资源无法释放而程序不能失败，请尝试把这个故障用某种方式通知给系统中的其他部分
（也许甚或修改某个全局状态，并希望有人能注意到它并有能力处理这个问题）。
请充分警惕，这种技巧是有专门用途的，并且容易出错。
请考虑“连接关闭不了”的那个例子。
这也许是因为连接的另一端出现了问题，但只有对连接的两端同时负责的代码才能恰当地处理这个问题。
析构函数可以向系统中负责管控的部分发送一个消息（或别的什么），然后认为已经关闭了连接并正常返回。

##### 注解

如果析构函数所用的操作可能会失败的话，它可以捕获这些异常，某些时候仍然可以成功完成执行
（例如，换用与抛出异常的清理机制不同的另一种机制）。

##### 强制实施

【简单】 析构函数应当声明为 `noexcept`。

### <a name="Rc-dtor-noexcept"></a>C.37: 使析构函数 `noexcept`

##### 理由

[析构函数不能失败](#Rc-dtor-fail)。如果析构函数试图抛出异常来退出，这就是一种设计错误，程序最好终止执行。

##### 注解

当类中的所有成员都带有 `noexcept` 析构函数时，析构函数（无论是自定义的还是编译器生成的）将被隐含地声明为 `noexcept`（这与其函数体中的代码无关）。

##### 强制实施

【简单】 析构函数应当声明为 `noexcept`。

## <a name="SS-ctor"></a>C.ctor: 构造函数

构造函数定义对象如何进行初始化（构造）。

### <a name="Rc-ctor"></a>C.40: 如果类具有不变式，请为其定义构造函数

##### 理由

这正是构造函数的用途。

##### 示例

    class Date {  // Date 表示从 1900/1/1 到 2100/12/31 范围中
                  // 的一个有效日期
        Date(int dd, int mm, int yy)
            :d{dd}, m{mm}, y{yy}
        {
            if (!is_valid(d, m, y)) throw Bad_date{};  // 不变式的实施
        }
        // ...
    private:
        int d, m, y;
    };

把不变式表达为构造函数上的一个 `Ensures` 通常是一种好做法。

##### 注解

即便类并没有不变式，也可以用构造函数来简化代码。例如：

    struct Rec {
        string s;
        int i {0};
        Rec(const string& ss) : s{ss} {}
        Rec(int ii) :i{ii} {}
    };

    Rec r1 {7};
    Rec r2 {"Foo bar"};

##### 注解

C++11 的初始化式列表规则免除了对许多构造函数的需求。例如：

    struct Rec2{
        string s;
        int i;
        Rec2(const string& ss, int ii = 0) :s{ss}, i{ii} {}   // 多余的
    };

    Rec r1 {"Foo", 7};
    Rec r2 {"Bar"};

`Rec2` 的构造函数是多余的。
同样的，`int` 的默认值最好用[成员初始化式](#Rc-in-class-initializer)来给出。

**参见**: [构造有效对象](#Rc-complete)和[构造函数抛出异常](#Rc-throw)。

##### 强制实施

* 对带有自定义的复制操作但没有构造函数的类进行标记（自定义的复制操作是类是否带有不变式的良好指示器）

### <a name="Rc-complete"></a>C.41: 构造函数应当创建经过完整初始化的对象

##### 理由

构造函数为类设立不变式。类的使用者应当能够假定构造完成的对象是可以使用的。

##### 示例，不好

    class X1 {
        FILE* f;   // 在任何其他函数之前应当调用 init()
        // ...
    public:
        X1() {}
        void init();   // 初始化 f
        void read();   // 从 f 中读取数据
        // ...
    };

    void f()
    {
        X1 file;
        file.read();   // 程序崩溃或者错误的数据读取！
        // ...
        file.init();   // 太晚了
        // ...
    }

编译器读不懂代码注释。

**例外**: 如果无法方便地通过构造函数来构造有效的对象的话，请[使用工厂函数](#Rc-factory)。

##### 注解

如果构造函数（为创建有效的对象）获取了某个资源，则这个资源应当[由析构函数释放](#Rc-dtor-release)。
这种以构造函数获取资源并以析构函数来释放的惯用法被称为 [RAII](#Rr-raii)（“资源获取即初始化/Resource Acquisition Is Initialization”）。

### <a name="Rc-throw"></a>C.42: 当构造函数无法构造有效对象时，应当抛出异常

##### 理由

留下无效对象不管就是会造成麻烦的做法。

##### 示例

    class X2 {
        FILE* f;   // 在任何其他函数之前应当调用 init()
        // ...
    public:
        X2(const string& name)
            :f{fopen(name.c_str(), "r")}
        {
            if (f == nullptr) throw runtime_error{"could not open" + name};
            // ...
        }

        void read();      // 从 f 中读取数据
        // ...
    };

    void f()
    {
        X2 file {"Zeno"}; // 当文件打不开时会抛出异常
        file.read();      // 好的
        // ...
    }

##### 示例，不好

    class X3 {     // 不好: 构造函数留下了无效的对象
        FILE* f;   // 在任何其他函数之前应当调用 init()
        bool valid;
        // ...
    public:
        X3(const string& name)
            :f{fopen(name.c_str(), "r")}, valid{false}
        {
            if (f) valid = true;
            // ...
        }

        void is_valid() { return valid; }
        void read();   // 从 f 中读取数据
        // ...
    };

    void f()
    {
        X3 file {"Heraclides"};
        file.read();   // 程序崩溃或错误的数据读取！
        // ...
        if (is_valid()) {
            file.read();
            // ...
        }
        else {
            // ... 处理错误 ...
        }
        // ...
    }

##### 注解

对于变量的定义式（比如在栈上，或者作为其他对象的成员），不存在可以返回错误代码的明确函数调用。
留下无效的对象并依赖使用者能够一贯地在使用之前检查 `is_valid()` 函数是啰嗦的，易错的，并且是低效的做法。

**例外**: 有些领域，比如像飞行器控制这样的硬实时系统中，（在没有其他工具支持下）异常处理在计时方面不具有足够的可预测性。
这样的话就必须使用 `is_valid()` 技巧。这种情况下，可以一贯并即刻地检查 `is_valid()` 来模拟 [RAII](#Rr-raii)。

**替代方案**: 如果你觉得想要使用某种“构造函数之后初始化”或者“两阶段初始化”手法，请试着避免这样做。
如果你确实要如此的话，请参考[工厂函数](#Rc-factory)。

##### 注解

人们使用 `init()` 函数而不是在构造函数中进行初始化的一种原因是为了避免代码重复。
[委派构造函数](#Rc-delegating)和[默认成员初始化式](#Rc-in-class-initializer)可以更好地做到这点。
另一种原因是为了把初始化推迟到需要对象的位置；它的解决方法通常为“[直到变量可以正确进行初始化的位置再声明变量](#Res-init)”。

##### 强制实施

* 【简单】 每个构造函数都应当对每个成员变量进行初始化（明确地，通过委派构造函数调用，或者通过默认构造）。
* 【未知】 如果构造函数带有 `Ensures` 契约的话，尝试确定它给出的是否是一项后条件。

### <a name="Rc-default0"></a>C.43: 保证类带有默认构造函数

##### 理由

许多的语言和程序库设施都依赖于默认构造函数来初始化其各个元素，比如 `T a[10]` 和 `std::vector<T> v(10)`。

##### 示例，不好

    class Date { // 不好: 缺少默认构造函数
    public:
        Date(int dd, int mm, int yyyy);
        // ...
    };

    vector<Date> vd1(1000);   // 需要默认的 Date
    vector<Date> vd2(1000, Date{Month::october, 7, 1885});   // 替代方式

仅当没有用户声明的构造函数时，默认构造函数才会自动生成，因此上面的例子中的 vector `vdl` 是无法进行初始化的。

“天然的”默认日期是不存在的（大爆炸对大多数人来说在时间上太过久远了），因此这并非是毫无意义的例子。
`{0, 0, 0}` 在大多数历法系统中都不是有效的日期，因此选用它可能会引入某种如同浮点的 `NaN` 这样的东西。
不过，大多数现实的 `Date` 类都有某个“首日”（比如很常见的 1970/1/1），因此以它为默认日期通常很容易做到。

##### 示例

    class Date {
    public:
        Date(int dd, int mm, int yyyy);
        Date() = default; // 参见 C.45
        // ...
    private:
        int dd = 1;
        int mm = 1;
        int yyyy = 1970;
        // ...
    };

    vector<Date> vd1(1000);

##### 注解

所有成员都带有默认构造函数的类，隐含得到一个默认构造函数：

    struct X {
        string s;
        vector v;
    };

    X x; // 意为 X{ {}, {} }; 即空字符串和空 vector

需要注意的是，内建类型并不会进行正确的默认构造：

    struct X {
       string s;
       int i;
    };

    void f()
    {
       X x;    // x.s 被初始化为空字符串; x.i 未初始化

       cout << x.s << ' ' << x.i << '\n';
       ++x.i;
    }

静态分配的内建类型对象被默认初始化为 `0`，但局部的内建变量并非如此。
请注意你的编译期也许默认初始化了局部内建变量，而它在优化构建中并不会这样做。
因此，上例这样的代码也许恰好可以工作，但这其实依赖于未定义的行为。
假定你确实需要初始化的话，可以使用明确的默认初始化：

    struct X {
       string s;
       int i {};   // 默认初始化（为 0）
    };


##### 强制实施

* 标记没有默认构造函数的类。

### <a name="Rc-default00"></a>C.44: 尽量让默认构造函数简单且不抛出异常

##### 理由

如果可以设置一个“默认”值同时又不会涉及可能失败的操作的话，就可以简化错误处理以及对移动操作的推理。

##### 示例，有问题的

    template<typename T>
    class Vector0 {   // elem 指向以 new 分配的 space-elem 个元素
    public:
        Vector0() :Vector0{0} {}
        Vector0(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}
        // ...
    private:
        own<T*> elem;
        T* space;
        T* last;
    };

这段代码很不错而且通用，不过在发生错误之后把一个 `Vector0` 进行置空会涉及一次分配，而它是可能失败的。
而且把默认的 `Vector` 表示为 `{new T[0], 0, 0}` 也比较浪费。
比如说，`Vector0 v(100)` 会耗费 100 次分配操作。

##### 示例

    template<typename T>
    class Vector1 {   // elem 为 nullptr，否则 elem 指向以 new 分配的 space-elem 个元素
    public:
        Vector1() noexcept {}   // 设置表示为 {nullptr, nullptr, nullptr}; 不会抛出异常
        Vector1(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}
        // ...
    private:
        own<T*> elem = nullptr;
        T* space = nullptr;
        T* last = nullptr;
    };

表示为 `{nullptr, nullptr, nullptr}` 的 `Vector1{}` 很廉价，但这是一种特殊情况并且隐含了运行时检查。
在检测到错误后可以很容易地把 `Vector1` 置空。

##### 强制实施

* 标记会抛出的默认构造函数

### <a name="Rc-default"></a>C.45: 不要定义仅对数据成员进行初始化的默认构造函数；应当使用成员初始化式

##### 理由

使用类内部的成员初始化式，编译器可以据此生成函数。由编译器生成的函数可能更高效。

##### 示例，不好

    class X1 { // 不好: 未使用成员初始化式
        string s;
        int i;
    public:
        X1() :s{"default"}, i{1} { }
        // ...
    };

##### 示例

    class X2 {
        string s = "default";
        int i = 1;
    public:
        // 使用编译期生成的默认构造函数
        // ...
    };

##### 强制实施

【简单】 默认构造函数应当不只是用常量初始化成员变量。

### <a name="Rc-explicit"></a>C.46: 默认情况下，把单参数的构造函数声明为 `explicit`

##### 理由

用以避免意外的类型转换。

##### 示例，不好

    class String {
        // ...
    public:
        String(int);   // 不好
        // ...
    };

    String s = 10;   // 意外: 大小为 10 的字符串

##### 例外

如果确实想要从构造函数参数类型隐式转换为类类型的话，就不使用 `explicit`：

    class Complex {
        // ...
    public:
        Complex(double d);   // OK: 希望进行从 d 向 {d, 0} 的转换
        // ...
    };

    Complex z = 10.7;   // 无意外的转换

**参见**: [有关隐式转换的讨论](#Ro-conversion)。

##### 强制实施

【简单】 单参数的构造函数应当声明为 `explicit`。有益的单参数非 `explicit` 构造函数在大多数代码库中都是很少见的。对没在“已确认列表”中列出的每个违例都要给出警告。

### <a name="Rc-order"></a>C.47: 按成员声明的顺序对成员变量进行定义和初始化

##### 理由

以尽量避免混淆和错误。该顺序正是初始化的发生顺序（而这与成员初始化式的顺序无关）。

##### 示例，不好

    class Foo {
        int m1;
        int m2;
    public:
        Foo(int x) :m2{x}, m1{++x} { }   // 不好: 有误导性的初始化式顺序
        // ...
    };

    Foo x(1); // 意外: x.m1 == x.m2 == 2

##### 强制实施

【简单】 成员初始化式的列表中应当以成员声明的相同顺序列出各个成员。

**参见**: [讨论](#Sd-order)

### <a name="Rc-in-class-initializer"></a>C.48: 对于常量初始化式来说，优先采用类中的初始化式而不是构造函数中的成员初始化式

##### 理由

明确所有构造函数都将使用相同的值。避免重复。避免可维护性问题。这样做会产生最简短最高效的代码。

##### 示例，不好

    class X {   // 不好
        int i;
        string s;
        int j;
    public:
        X() :i{666}, s{"qqq"} { }   // j 未初始化
        X(int ii) :i{ii} {}         // s 为 "" 而 j 未初始化
        // ...
    };

维护者如何能看出 `j` 是否是故意未初始化的（尽管这可能是个糟糕的想法），而且是不是故意要使 `s` 的默认值在一种情况下为 `""` 而另一种情况下为 `qqq` 呢（几乎可以肯定是个 Bug）？这里 `j` 的问题（忘记对成员初始化）通常会出现在向现存类中添加新成员的时候。

##### 示例

    class X2 {
        int i {666};
        string s {"qqq"};
        int j {0};
    public:
        X2() = default;        // 所有成员都初始化为默认值
        X2(int ii) :i{ii} {}   // s 和 j 被初始化为默认值
        // ...
    };

**替代方案**: 也可以用构造函数的默认实参来获得一部分的好处，而且这在比较老的代码中也并不少见。不过这种方式不够直白，会导致需要传递较多的参数，并且当有多个构造函数时也会造成重复：

    class X3 {   // 不好: 不明确，参数传递开销
        int i;
        string s;
        int j;
    public:
        X3(int ii = 666, const string& ss = "qqq", int jj = 0)
            :i{ii}, s{ss}, j{jj} { }   // 所有成员都初始化为默认值
        // ...
    };

##### 强制实施

* 【简单】 每个构造函数都应该对所有成员变量进行初始化（明确进行，通过委派构造函数调用，或者通过默认构造）。
* 【简单】 构造函数的默认实参的出现表明类内部的初始化式可能更合适。

### <a name="Rc-initialize"></a>C.49: 在构造函数中，优先进行初始化而不是赋值

##### 理由

初始化语法明确指出所进行的是初始化而不是赋值，它更加精炼和高效。这样也避免了“未设值前就使用”的错误。

##### 示例，好

    class A {   // 好
        string s1;
    public:
        A() : s1{"Hello, "} { }    // 好: 直接构造
        // ...
    };

##### 示例，不好

    class B {   // 不好
        string s1;
    public:
        B() { s1 = "Hello, "; }   // 不好: 执行默认构造函数之后进行赋值
        // ...
    };

    class C {   // 恶劣，非常不好
        int* p;
    public:
        C() { cout << *p; p = new int{10}; }   // 意外，初始化前就被使用了
        // ...
    };

### <a name="Rc-factory"></a>C.50: 当初始化过程中需要体现“虚函数行为”时，请使用工厂函数

##### 理由

当基类对象的状态必须依赖于对象的派生部分的状态时，需要使用虚函数（或等价手段），并最小化造成误用和不完全构造的对象的机会窗口。

##### 示例，不好

    class B {
    public:
        B()
        {
            // ...
            f();   // 不好: 构造函数中的虚函数调用
            // ...
        }

        virtual void f() = 0;

        // ...
    };

##### 示例

    class B {
    protected:
        B() { /* ... */ }                   // 创建不完全初始化的对象

        virtual void PostInitialize()       // 构造之后立即调用
        {
            // ...
            f();    // 好: 虚函数分派是安全的
            // ...
        }

    public:
        virtual void f() = 0;

        template<class T>
        static shared_ptr<T> Create()    // 创建对象的接口
        {
            auto p = make_shared<T>();
            p->PostInitialize();
            return p;
        }
    };

    class D : public B { /* "¦ */ };            // 某个派生类

    shared_ptr<D> p = D::Create<D>();        // 创建一个 D 的对象

通过使构造函数为 `protected`，避免不完全构造的对象泄漏出去。
通过提供工厂函数 `Create()`，（在自由存储上）构造对象变得简便。

##### 注解

根据惯例，工厂方法在自由存储上进行分配，而不是在运行栈或者某个外围对象之内进行。

**参见**: [讨论](#Sd-factory)

### <a name="Rc-delegating"></a>C.51: 用委派构造函数来表示类中所有构造函数的共同行为

##### 理由

以避免代码重复和意外出现的差异。

##### 示例，不好

    class Date {   // 不好: 有重复
        int d;
        Month m;
        int y;
    public:
        Date(int ii, Month mm, year yy)
            :i{ii}, m{mm} y{yy}
            { if (!valid(i, m, y)) throw Bad_date{}; }

        Date(int ii, Month mm)
            :i{ii}, m{mm} y{current_year()}
            { if (!valid(i, m, y)) throw Bad_date{}; }
        // ...
    };

写这些共同行为很啰嗦，而且可能意外出现不一致。

##### 示例

    class Date2 {
        int d;
        Month m;
        int y;
    public:
        Date2(int ii, Month mm, year yy)
            :i{ii}, m{mm} y{yy}
            { if (!valid(i, m, y)) throw Bad_date{}; }

        Date2(int ii, Month mm)
            :Date2{ii, mm, current_year()} {}
        // ...
    };

**参见**: 当“重复行为”是简单的初始化时，考虑使用[类内部的成员初始化式](#Rc-in-class-initializer)。

##### 强制实施

【中等】 查找相似的构造函数体。

### <a name="Rc-inheriting"></a>C.52: 使用继承构造函数来把构造函数引入到无须进行其他的明确初始化操作的派生类之中

##### 理由

当派生类需要这些构造函数时，重新实现它们既啰嗦又容易出错。

##### 示例

`std::vector` 有许多棘手的构造函数，如果我想要创建自己的 `vector` 的话，我并不想重新实现它们：

    class Rec {
        // ... 数据，以及许多不错的构造函数 ...
    };

    class Oper : public Rec {
        using Rec::Rec;
        // ... 没有数据成员 ...
        // ... 许多不错的工具函数 ...
    };

##### 示例，不好

    struct Rec2 : public Rec {
        int x;
        using Rec::Rec;
    };

    Rec2 r {"foo", 7};
    int val = r.x;   // 未初始化

##### 强制实施

确保派生类的每个成员都被初始化。

## <a name="SS-copy"></a>C.copy: 复制和移动

值类型一般都应当是可以复制的，而类层次中的接口则不应如此。
资源包装可以复制也可以不能复制。
我们可以基于逻辑因素，也可以为性能原因而将类型定义为可移动的。

### <a name="Rc-copy-assignment"></a>C.60: 使复制赋值非 `virtual`，接受 `const&` 的参数，并返回非 `const` 的引用

##### 理由

这样做简单且高效。如果想对右值进行优化，则可以提供一个接受 `&&` 的重载（参见 [F.24](#Rf-pass-ref-ref)）。

##### 示例

    class Foo {
    public:
        Foo& operator=(const Foo& x)
        {
            auto tmp = x;   // 好: 不需要检查自赋值的情况（除非为性能考虑）
            std::swap(*this, tmp);
            return *this;
        }
        // ...
    };

    Foo a;
    Foo b;
    Foo f();

    a = b;    // 用左值赋值：复制
    a = f();  // 用右值赋值：可能进行移动

##### 注解

`swap` 实现技巧可以提供[强保证](???)。

##### 示例

如果不产生临时副本能够得到明显好得多的性能的话应当怎么办呢？考虑一个简单的 `Vector` 类，其所使用的领域中常常要对大型的、大小相同的 `Vector` 进行赋值。这种情况下，`swap` 实现技巧中所蕴含的元素复制操作将导致运行成本按数量级增长。

    template<typename T>
    class Vector {
    public:
        Vector& operator=(const Vector&);
        // ...
    private:
        T* elem;
        int sz;
    };

    Vector& Vector::operator=(const Vector& a)
    {
        if (a.sz > sz) {
            // ... 使用 swap 技巧，没有更好的方式了 ...
            return *this
        }
        // ... 从 *a.elem 复制 sz 个元素给 elem ...
        if (a.sz < sz) {
            // ... 销毁 *this* 中过剩的元素并调整大小 ...
        }
        return *this;
    }

直接向目标元素中进行写入的话，我们得到的是[基本保证](#???)而不是 `swap` 技巧所提供的强保证。还要当心[自赋值](#Rc-copy-self)。

**替代方案**: 如果你想要 `virtual` 的赋值运算符，并了解为何这样做很有问题的话，请不要使其为 `operator=`。请使用一个命名函数，如 `virtual void assign(const Foo&)`。
参见[复制构造函数 vs. `clone()`](#Rc-copy-virtual)。

##### 强制实施

* 【简单】 赋值运算符不能为 `virtual`。有怪兽出没！
* 【简单】 赋值运算符应当返回 `T&` 以支持调用链，不要改为如 `const T&` 等类型，这样会影响可组合性以及把对象放入容器的能力。
* 【中等】 赋值运算符应当（隐式或者显式）调用所有的基类和成员的赋值运算符。
  检查析构函数以分辨类型具有指针语义还是值语义。

### <a name="Rc-copy-semantic"></a>C.61: 复制操作应当进行复制

##### 理由

这正是一般假定所具有的语义。执行 `x=y` 之后，应当有 `x == y`。
进行复制之后，`x` 和 `y` 可以是各自独立的对象（值语义，非指针的内建类型和标准库类型的工作方式），也可以代表某个共享的对象（指针语义，就是指针的工作方式）。

##### 示例

    class X {   // OK: 值语义
    public:
        X();
        X(const X&);     // 复制 X
        void modify();   // 改变 X 的值
        // ...
        ~X() { delete[] p; }
    private:
        T* p;
        int sz;
    };

    bool operator==(const X& a, const X& b)
    {
        return a.sz == b.sz && equal(a.p, a.p + a.sz, b.p, b.p + b.sz);
    }

    X::X(const X& a)
        :p{new T[a.sz]}, sz{a.sz}
    {
        copy(a.p, a.p + sz, a.p);
    }

    X x;
    X y = x;
    if (x != y) throw Bad{};
    x.modify();
    if (x == y) throw Bad{};   // 假定具有值语义

##### 示例

    class X2 {  // OK: 指针语义
    public:
        X2();
        X2(const X&) = default; // 浅拷贝
        ~X2() = default;
        void modify();          // 改变 X 的值
        // ...
    private:
        T* p;
        int sz;
    };

    bool operator==(const X2& a, const X2& b)
    {
        return a.sz == b.sz && a.p == b.p;
    }

    X2 x;
    X2 y = x;
    if (x != y) throw Bad{};
    x.modify();
    if (x != y) throw Bad{};  // 假定具有指针语义

##### 注解

应当优先采用复制语义，除非你要构建某种“智能指针”。值语义是最容易进行推理的，而且也是被标准库设施所期望的。

##### 强制实施

【无法强制实施】

### <a name="Rc-copy-self"></a>C.62: 使复制赋值可以安全进行自赋值

##### 理由

如果 `x=x` 会改变 `x` 的值的话，会让人惊异，并导致发生严重的错误（通常会含有资源泄漏）。

##### 示例

标准库的容器类都能优雅且高效地处理自赋值：

    std::vector<int> v = {3, 1, 4, 1, 5, 9};
    v = v;
    // v 的值仍然是 {3, 1, 4, 1, 5, 9}

##### 注解

从可以处理自赋值的成员所生成的默认复制操作是能够正确处理自赋值的。

    struct Bar {
        vector<pair<int, int>> v;
        map<string, int> m;
        string s;
    };

    Bar b;
    // ...
    b = b;   // 正确而且高效

##### 注解

可以通过明确检测自赋值来处理自赋值的情况，不过通常不进行这种检测会变得更快并且更优雅（比如说，[利用 `swap`](#Rc-swap)）。

    class Foo {
        string s;
        int i;
    public:
        Foo& operator=(const Foo& a);
        // ...
    };

    Foo& Foo::operator=(const Foo& a)   // OK，但增加了成本
    {
        if (this == &a) return *this;
        s = a.s;
        i = a.i;
        return *this;
    }

这显然是安全的，也貌似高效。
不过，如果一百万次赋值才会做一次自赋值会怎么样呢？
这样就有大约一百万次多余的测试（不过由于基本上每次的答案都相同，计算机的分支预测电路也基本上每次都会猜对）。
考虑：

    Foo& Foo::operator=(const Foo& a)   // 更简单，而且可能也更好
    {
        s = a.s;
        i = a.i;
        return *this;
    }

`std::string` 的自赋值是安全的，`int` 也是如此。所有的成本都将花在（罕见的）自赋值情况中。

##### 强制实施

【简单】 赋值运算符不应当包含 `if (this == &a) return *this;` 这样的代码模式 ???

### <a name="Rc-move-assignment"></a>C.63: 使移动赋值非 `virtual`，接受 `&&` 的参数，并返回非 `const` 的引用

##### 理由

这样简单而且高效。

**参见**: [针对复制赋值的规则](#Rc-copy-assignment)。

##### 强制实施

和针对[复制赋值](#Rc-copy-assignment)所做的相同。

* 【简单】 赋值运算符不能为 `virtual`。有怪兽出没！
* 【简单】 赋值运算符应当返回 `T&` 以支持调用链，不要改为如 `const T&` 等类型，这样会影响可组合性以及把对象放入容器的能力。
* 【中等】 移动赋值运算符应当（隐式或者显式）调用所有的基类和成员的移动赋值运算符。



