# <a name="main"></a>C++ 核心指导方针

2016/2/15

编辑：

* [Bjarne Stroustrup](http://www.stroustrup.com)
* [Herb Sutter](http://herbsutter.com/)

翻译：

* 李一楠 (li_yinan AT 163 DOT com)

本文档是早期草稿。本文档有错漏，格式也不正规。
本文档作为开源项目，发布版本为 0.6。
复制，使用，修改，以及创建本项目的衍生物，受到一份 MIT 风格的版权授权。
向本项目作出贡献需要同意一份贡献者授权。详情参见附属的 [LICENSE](LICENSE) 文件。
我们将本项目开放给“友好用户”进行使用，复制，修改，以及生产衍生物，并希望能够获得建设性的资源投入。

十分欢迎大家提出意见和改进建议。
随着我们的知识增长，随着语言和可用的程序库的改进，我们计划对这份文档不断进行修改和扩充。
当提出您的意见时，请关注[导言](#S-introduction)部分，其中概述了我们的目标和所采用的一般方法。
贡献者的列表请参见[这里](#SS-ack)。

已知问题：

* 仍未对规则集合的完整性、一致性和可强制实施性加以检查。
* 三问号 (???) 用于标记已知的信息缺失。
* 需要更新参考部分；许多前 C++11 的源代码都过于老旧。
* [To-do: 未分类的规则原型](#S-unclassified) 是一份基本上保持最新状态的 to-do 列表。

您可以[阅读本指南的范围和结构的说明](#S-abstract)，或者直接跳转到：

* [In: 导言](#S-introduction)
* [P: 理念](#S-philosophy)
* [I: 接口](#S-interfaces)
* [F: 函数](#S-functions)
* [C: 类和类层次](#S-class)
* [Enum: 枚举](#S-enum)
* [R: 资源管理](#S-resource)
* [ES: 表达式和语句](#S-expr)
* [E: 错误处理](#S-errors)
* [Con: 常量和不可变性](#S-const)
* [T: 模板和泛型编程](#S-templates)
* [CP: 并发](#S-concurrency)
* [SL: 标准库](#S-stdlib)
* [SF: 源文件](#S-source)
* [CPL: C 风格的编程](#S-cpl)
* [PRO: 剖面配置](#S-profile)
* [GSL: 指导方针支持库](#S-gsl)
* [FAQ: 常见问题的解答](#S-faq)

配套章节：

* [NL: 命名和代码布局](#S-naming)
* [PER: 性能](#S-performance)
* [N: 伪规则和错误的看法](#S-not)
* [RF: 参考资料](#S-references)
* [附录 A: 程序库](#S-libraries)
* [附录 B: 代码的现代化](#S-modernizing)
* [附录 C: 相关讨论](#S-discussion)
* [词汇表](#S-glossary)
* [To-do: 未分类的规则原型](#S-unclassified)

也可以查看具体的语言特性

* [赋值](#S-???)
* [`class`](#S-class)
* [构造函数](#SS-ctor)
* [派生 `class`](#SS-hier)
* [析构函数](#SS-dtor)
* [异常](#S-errors)
* [`for`](#S-???)
* [`inline`](#S-class)
* [初始化](#S-???)
* [lambda 表达式](#SS-lambdas)
* [运算符](#S-???)
* [`public`, `private`, 和 `protected`](#S-???)
* [`static_assert`](#S-???)
* [`struct`](#S-class)
* [`template`](#S-???)
* [`unsigned`](#S-???)
* [`virtual`](#SS-hier)

还有一些用于表达和讨论的术语的定义，它们不属于语言技术，而是有关设计和编程技术的术语。

* 错误（Error）
* 异常（Exception）
* 故障（Failure）
* 不变式（Invariant）
* 泄漏（Leak）
* 前条件（Precondition）
* 后条件（Postcondition）
* 资源（Resource）
* 异常保证（Exception Guarantee）

# <a name="S-abstract"></a>概要

本文档是一组有关如何更好使用 C++ 的指导方针的集合。
本文档的目标是帮助人们更有效地使用现代 C++。
所谓“现代”的含义是指 C++11 和 C++14（以及即将到来的 C++17）。
换句话说，如果你从现在开始算起，五年后你的代码看起来是怎么样的？十年呢？

这些指导方针所关注的是一些相对比较高层次的问题，比如接口，资源管理，内存管理，以及并发等等。
这样的规则会对应用的架构，以及程序库的设计都造成影响。
如果遵循这些规则，代码将会是静态类型安全的，没有资源泄露，并且能够捕捉到比当今的代码通常所能捕捉到的多得多的编程逻辑错误。
还能更快速地运行——你不必牺牲程序的正确性。

我们对于如命名约定和缩进风格一类的低层次的问题不那么关注。
当然，对程序员有帮助的任何话题都是可接受的。

我们最初的规则集合强调的是（各种形式的）安全性以及简单性。
它们有些过于严格了。
我们预期将会引入更多的例外情况， 以便使它们更好地适应现实世界的需要。
我们也需要更多的规则。

您可能会发现，有的规则与您的预期相反，甚至是与您的经验相违背。
其实如果我们没建议您在任何方面改变您的编码风格，那其实就是我们的失败！
请您尝试验证或者证伪这些规则吧！
尤其是，我们十分期望让一些规则能够建立在真实的测量数据上，或者是一些更好的例子之上。

您可能会觉得一些规则很显然，甚至没有什么价值。
但请记住，指导方针的目的之一就在于帮助那些经验不足的，或来自其他背景或使用其他语言的人，能够迅速行动起来。

这里的许多规则有意设计成可以由分析工具提供支持的。
违反规则的代码会打上标记，以引用（或者链接）到相关的规则。
您在开始编码前并不需要记住所有这些规则。
一种看待这些指导方针的方式，是一份恰好可以让人类读懂的针对这些工具的规范文件。

这些规则都是为了逐步引入一个代码库而设计的。
我们计划建立这样的工具，并希望其他人也能提供它们。

十分欢迎大家提出意见和改进建议。
随着我们的知识增长，随着语言和可用的程序库的改进，我们计划对这份文档不断进行修改和扩充。

# <a name="S-introduction"></a>In: 导言

本文档是一组核心指导方针，针对现代 C++（C++14），还考虑到了语言将来有希望的增强，以及 ISO 技术规范（TSs）。
其目标是帮助 C++ 程序员编写更简单、更高效、更加可维护的代码。

导言概览：

* [In.target: 目标读者](#SS-readers)
* [In.aims: 目标](#SS-aims)
* [In.not: 非目标](#SS-non)
* [In.force: 强制实施](#SS-force)
* [In.struct: 本文档的结构](#SS-struct)
* [In.sec: 主要章节](#SS-sec)

## <a name="SS-readers"></a>In.target: 目标读者

所有 C++ 程序员。其中也包括[考虑采用 C 语言的程序员](#S-cpl)。

## <a name="SS-aims"></a>In.aims: 目标

本文档的目标是帮助开发者采用现代 C++（C++11，C++14，以及不久后的 C++17），并在各个代码库之间达成更加统一的编码风格。

我们并不妄想这些规则中的每一条都能有效地在任何代码库中进行实施。对老旧系统进行升级是很困难的。不过我们确实认为，采纳了一条规则的程序总会比不这样做的程序更加不易出错也更加便于维护。通常，采用规则也会带来更快速或更容易的初始开发活动。
就我们所能说的，这些规则能够使得代码的性能，相对于更传统的技术来说同样好甚至更好；它们都是依照零开销原则设立的——“不使用就没有负担”（"what you don't use, you don't pay for"）或“当恰当地使用抽象机制时，所得的性能至少与使用低级语言构造手工编码的结果一样好”。
我们认为这些规则对新代码来说是理想的，也有很多机会在老代码中实施，并使这两者尽可能接近。
请记住：

### <a name="R0"></a>In.0: 不要慌张！

请花些时间理解一下指南规则对你的程序能够造成的影像。

这些指导方针都是遵循“超集的子集”原则（[Stroustrup05](#Stroustrup05)）而设计的。
它们并非仅仅定义了 C++ 的一个可以使用的子集（以获得比如说可靠性，安全性，性能，或者别的什么）。
它们强烈地推崇使用一些简单的“扩展”（[程序库组件](#S-gsl)），
使得最易出错的 C++ 特性变得不再必须，并且可以（通过这些规则）禁止再使用它们。

这些规则都强调静态类型安全性和资源安全性。
鉴于此，它们强调了进行范围检查，避免对 `nullptr` 解引用，避免悬挂指针，以及（通过 RAII）系统性地使用异常的可能性。
部分地为达成这点，也部分地为了最小化会带来错误的晦涩难懂的代码，这些规则同样强调了简单性，以及将必须的复杂性隐藏于经过充分说明的接口后面。

有许多规则都是约定性质的。
我们认为，那些单纯说“禁止这样！”而又不提供替代方案的规则是不可取的。
但这样的后果就是让一些规则只能以启发式方法，而不是精确地和机械化地进行验证检查。
还有一些规则所表达的是一些一般性的原则。对于这些一般性规则，我们会提供一些更精细和更特定的规则来进行不完全的检查。

这些指导方针所关注的是 C++ 的核心部分及其使用方式。
我们认为大多数的大型团体，特定的应用领域，甚至一些大型项目都会需要更多的规则，也许是更多的限制规则，或是更多的库支持。
例如说，硬实时开发人员通常都无法随意使用自由存储（动态内存），并且在选择程序库上也有许多限制。
我们鼓励各方开发这样的专门规则，以作为我们的核心指导方针的补充。
请构建你自己的基础程序库并使用它，而不要把你的开发层次降低到汇编代码之中。

这些规则的设计使其能够进行[渐进式的采纳](#S-modernizing)。

一些规则的目标是提升各种形式的安全性，而另外一些的目标是减少意外的发生，还有许多则同时兼顾。
目标是避免意外事故的指导方针通常会禁止完全合法的 C++ 用法。
不管怎样，每当存在两种达成效果的方式，其中一种被证实是常见的错误来源，而另外一种并非如此时，我们都会努力引导程序员采纳后者。

## <a name="SS-non"></a>In.not: 非目标

我们没打算让这些规则保持精简或正交。
特别地说，一般性规则可以很简单，但却没办法强制实施。
而且要搞清楚一条一般性规则所造成的影响通常是很困难的。
通常更专门的规则都更易于理解清楚，也更易于实施，但如果没有那些一般性规则的话，它们不过是一大堆特殊情况而已。
我们既要提供能够帮到新手的规则，也要提供能够支持专家使用的规则。
其中的一些规则是完全可以强制实行的，而另外的一些则是基于启发式方案的规则。

并不需要像读书一样从头到尾地阅读这些规则。
您可以利用链接来进行浏览。
不过，这些规则的主要预期用途是作为工具的检查目标。
就是说，由工具来查找规则的违反情况，然后工具会返回指向所违反的规则的链接。
而规则之中则提供了其理由，违反规则的潜在后果的例子，以及一些改正建议。

这些指导方针并不是用来替代 C++ 的教程材料的。
如果您需要针对某个经验水平的教程，请参见[参考资料](#S-references)。

本文档并不是一份如何把老旧 C++ 代码转化为更加现代的代码的指南。
而是旨在以一种具体化的方式来阐明对于新代码的设想。
当然，对于进行代码现代化，使其恢复活力或者升级的可行方式，可以参考[代码现代化章节](#S-modernizing)。
重要的是，这些规则是允许渐进式采纳的：对大型代码库进行一次性全部转化通常都是不可行的。

这些指导方针并不会对于语言技术的每个细节上都保持完整和精确。
如果需要，请参考 C++ 标准，关于语言定义上的最终文本，其中包括一般性规则的每种例外情况，也包括所有特性。

这些规则不是为了强迫你使用 C++ 的某个阉割子集来编写代码的。
它们*尤其着重*避免去定义一种像（比如）Java 一样的 C++ 子集。
它们也避免去定义一个单一的所谓“真正的 C++”的语言。
我们重视语言的表达能力和不打折扣的性能。

这些规则并不是价值观中立的。
它们旨在使代码变得相对于现有大多数 C++ 代码来说更简单，并且更加正确和安全，又不会有任何性能损失。
它们旨在约束对那些完全合法的，但却与错误、虚假的复杂性以及不良性能有关的 C++ 代码的使用。

## <a name="SS-force"></a>In.force: 强制实施

无法强制实施的规则对于大型代码库来说是难以操作的。
所有规则都强制实施，则仅对于一个小的规则集合，或者对于某些特定用户群来说是可行的。
但我们需要大量的规则，需要每个人都能使用的规则。
不同的人的要求都不一样。
人们不想阅读大量的规则。
人们也无法记住太多规则。
因此，我们需要建立规则子集以满足各种不同的需要。
但任意性地建立子集也会导致混乱：我们想要的是可以帮助到许多人的指导方针，使代码更加统一，并有力地促进人们将他们的代码现代化。
我们想要促进最佳实践，而不是让人们陷入大量选项之中而增加管理压力。
理想情况是使用全部规则；这会带来极大的好处。

但这样也带来了一些困难之处。
我们试图通过使用工具来解决它们。
每条规则都包括一个**强制实施**小节，列出了进行强制实施的一些建议。
所谓强制实施，可以是通过代码评审，通过静态分析，通过编译器，或者通过运行时检查来进行的。
只要可行，我们都倾向于“机械性的”检查（人类是缓慢的，不精确的，而且很容易疲倦）和静态检查。
只有当不存在其他方案时，我们才偶尔建议进行运行时检查；我们并不想带来所谓“分散肥肉”。
如果适当的话，我们会（在**强制实施**小节中）将规则标以相关的规则组的名字（所谓“剖面配置”）。
一条规则可以属于多个剖面配置，也可以不属于任何剖面配置。
首先，我们有一些对应于常规需求（期望、理想目标）的剖面配置：

* **type**: 消除类型违规（如通过强制转换（cast）、联合体（union）或者变参（varargs）把 `T` 重解释为 `U`）
* **bounds**: 消除边界违规（如越过数组范围的访问）
* **lifetime**: 消除泄漏（如未能 `delete` 或者进行多次 `delete`），以及消除对无效对象的访问（如解引用 `nullptr`，或使用悬挂引用）。

这些剖面配置是为工具的使用而准备的，但对人类读者也能有所帮助。
我们不打算把**强制实施**小节中的评述限定在我们了解如何强制实施的方面；其中的一些说明仅仅是一些愿望，它们可能会对一些工具构建者们造成影响。

实现这些规则的工具应当遵循下面的语法以明确抑制一条规则：

    [[suppress(tag)]]
    
其中的 "tag" 是包含强制规则的条目的锚定名字（例如，C.134 的锚定名字为 "Rh-public"），
剖面配置的规则组的名字（如 "type"，"bounds"，或 "lifetime"），或者剖面配置中的特定规则（"type.4" 或 "bounds.2"）。


## <a name="SS-struct"></a>In.struct: 本文档的结构

每条规则（指导方针，建议）可以包含几个部分：

* 规则本身 —— 例如，**不要使用裸 `new`**
* 一个规则参考编号 —— 例如，**C.7**（与类相关的第七条规则）。
  因为大章节之间天然是无序的，所以我们用一个字母来当作规则参考“编号”的第一个部分。
  我们在编号之间保留了一些间隔，以便当添加或删减规则时尽量减少“断裂”。
* **理由**（原理） —— 程序员对于他们不理解的规则是难于遵守的
* **示例** —— 抽象地理解规则是很难的；示例有正面的和负面的
* **替代方案** —— 针对“请勿……”规则
* **例外** —— 我们更喜欢简单的一般性规则。但是许多规则都是广泛适用，但并不是普遍适用的，因此必须列出例外情况
* **强制实施** —— 关于这条规则如何“机械性”地进行检查的建议
* **参见** —— 指向相关的规则，以及（本文档中或者别处的）进一步讨论
* **注解** —— 需要说明的一些内容，无法被归类到其他部分
* **探讨** —— 指向规则主列表之外的更加全面的原理说明和实例

一些规则难于机械地进行检查，但它们都满足一条最小准则，即专家程序员可以不费太多力气就能找出许多违反情况。
我们希望“机械性”工具能够随着时间获得改进，以接近这种专家程序员所能发觉的程度。
而且，我们还认为这些规则也会随着时间获得提炼，以变得更明确和易于检查。

规则应当简明，而不是谨慎地列出每种变化和特殊情况。
这些信息应当出现在**替代方案**段落和[探讨](#S-discussion)章节中。
如果您不理解或者反对一条规则，请您访问它的**探讨**部分。
如果您觉得一份探讨有缺漏或不完整，请填写一条 [Issue](https://github.com/isocpp/CppCoreGuidelines/issues)
来解释您的关切，亦或一条相应的问题报告。

本文档不是语言手册。
它旨在能够对人有所帮助，而不是变得完整，在技术细节上完全准确，或对现存代码的指南。
可以在[参考资料](#S-references)中找到一些推荐的信息来源。

## <a name="SS-sec"></a>In.sec: 主章节

* [In: 导言](#S-introduction)
* [P: 理念](#S-philosophy)
* [I: 接口](#S-interfaces)
* [F: 函数](#S-functions)
* [C: 类和类层次](#S-class)
* [Enum: 枚举](#S-enum)
* [R: 资源管理](#S-resource)
* [ES: 表达式和语句](#S-expr)
* [E: 错误处理](#S-errors)
* [Con: 常量和不可变性](#S-const)
* [T: 模板和泛型编程](#S-templates)
* [CP: 并发](#S-concurrency)
* [SL: 标准库](#S-stdlib)
* [SF: 源文件](#S-source)
* [CPL: C 风格的编程](#S-cpl)
* [PRO: 剖面配置](#S-profile)
* [GSL: 指导方针支持库](#S-gsl)
* [FAQ: 常见问题的解答](#S-faq)

配套章节：

* [NL: 命名和代码布局](#S-naming)
* [PER: 性能](#S-performance)
* [N: 伪规则和错误的看法](#S-not)
* [RF: 参考资料](#S-references)
* [附录 A: 程序库](#S-libraries)
* [附录 B: 代码的现代化](#S-modernizing)
* [附录 C: 相关讨论](#S-discussion)
* [词汇表](#S-glossary)
* [To-do: 未分类的规则原型](#S-unclassified)

章节之间并非是正交的。

每个章节（比如，"P" 代表“理念”），以及每个子章节（比如，"C.hier" 代表“类层次（OOP）”）都有一个用以简化搜索和引用的缩写。
主章节的缩写也出现在规则编号之中（比如，"C.11" 代表“使具体类型正规化”）。

# <a name="S-philosophy"></a>P: 理念

本章节中的规则都非常具有一般性。

理念性规则概览：

* [P.1: 在代码中直接表达你的想法](#Rp-direct)
* [P.2: 用 ISO 标准 C++ 来编码](#Rp-Cplusplus)
* [P.3: 表达你的设计意图](#Rp-what)
* [P.4: 理想情况下，程序应当是静态类型安全的](#Rp-typesafe)
* [P.5: 编译期检查优先于运行时检查](#Rp-compile-time)
* [P.6: 应当使无法在编译期进行的检查能够在运行时实施](#Rp-run-time)
* [P.7: 尽早捕获运行时错误](#Rp-early)
* [P.8: 不要泄漏任何资源](#Rp-leak)
* [P.9: 不要浪费时间或空间](#Rp-waste)
* [P.10: 不可变数据优先于可变数据](#Rp-mutable)

通常，理念性的规则都无法机械性地进行检查。
不过，这些理念主题在各个规则中都有体现。
如果没有一个理念基础的话，那些更具体、专门和可检查的规则就是缺少理论根据的了。

### <a name="Rp-direct"></a>P.1: 在代码中直接表达你的想法

##### 理由

编译器是不会去读注释（或设计文档）的，许多程序员也（固执地）不去读它们。
而代码中所表达的东西是带有明确的语义的，并且（原则上）是可以由编译器和其他工具进行检验的。

##### 示例

    class Date {
        // ...
    public:
        Month month() const;  // 好
        int month();          // 不好
        // ...
    };

`month` 的第一个声明式，显然是要返回一个 `Month`，而且不会修改 `Date` 对象的状态。
而第二个版本则需要读者进行猜测，同时带来了更多的出现难于发现 BUG 的可能性。

##### 示例

    void do_something(vector<string>& v)
    {
        string val;
        cin >> val;
        // ...
        int index = -1;            // 不好
        for (int i = 0; i < v.size(); ++i)
            if (v[i] == val) {
                index = i;
                break;
            }
        // ...
    }

这个循环是 `std::find` 的一种能力有限的形式。
要清晰得多地表达其设计意图，可以这样：

    void do_something(vector<string>& v)
    {
        string val;
        cin >> val;
        // ...
        auto p = find(begin(v), end(v), val);  // 好多了
        // ...
    }

用恰当设计的程序库来表达设计意图（要做什么，而不只是怎么做这些事），要远比直接使用语言功能好得多。

C++ 程序员应当熟知标准库的基本知识，并在适当的时候加以利用。
任何程序员都应当熟知其所工作的项目中的基础程序库的基本知识，并适当加以利用。
使用本文档的指导方针的程序员，应当熟知[指导方针支持库](#S-gsl)，并适当加以利用。

##### 示例

    change_speed(double s);   // bad: s 代表什么？
    // ...
    change_speed(2.3);

更好的方案是明确给出这个 double 的含义（新的速度还是对旧速度的增量？）以及所用单位：

    change_speed(Speed s);    // 好多了：说明了 s 的含义
    // ...
    change_speed(2.3);        // 错误：没有单位
    change_speed(23m / 10s);  // 米每秒

确实可以用普通的（没有单位的）`double` 作为增量值，但这样是易于出错的。
如果绝对速度值和增量值都需要的话，我们应当定义一个 `Delta` 类型。

##### 强制实施

通常非常困难。

* 坚持一贯地使用 `const`（检查成员函数是否会修改对象；检查函数是否会修改以指针或引用形式传递的实参）
* 将强制转换标示出来（强制转换阉割了类型系统）
* 检测模仿标准库的代码（困难）

### <a name="Rp-Cplusplus"></a>P.2: 用 ISO 标准 C++ 来编码

##### 理由

本文档正是关于用 ISO 标准 C++ 来编码的一组指导方针。

##### 注解

有些环境下是需要使用语言扩展的，例如有关访问系统资源的语言扩展。
这些情况下，应当将对所需语言扩展的使用局部化，并把它们的使用置于非核心的编码指导方针的控制之下。如果可能的话，应当构建一些接口来封装这些语言扩展，以使其能够被关闭，并当针对不支持这些语言扩展的系统时免除它们的编译。

语言扩展通常是没有严密定义的语义的。即便语言扩展很常见，
并且在多种编译器上都有实现，它们也可能有略微不一致的行为
以及边界情形下的行为，这是*缺乏*一个严格的标准定义的
直接后果。大量使用任何这样的语言扩展，都会对代码的可移植性
造成不良影响。

##### 注解

有些环境下是需要对标准 C++ 语言或者程序库的功能特性的使用进行限制的，例如，飞行器控制软件标准要求避免动态内存分配。
这些情况下，应当将对它们的使用（或废弃）置于对本文档针对特定环境所定制的扩充的编码指导方针之下。

##### 强制实施

使用最新版的 C++ 编译器（当前支持 C++11 或者 C++14），并打开禁用语言扩展的选项。

### <a name="Rp-what"></a>P.3: 表达你的设计意图

##### 理由

一些代码如果不（比如通过命名或者代码注释）说明其设计意图的话，是不可能搞清楚代码是否达成其预定目标的。

##### 示例

    int i = 0;
    while (i < v.size()) {
        // ... 在 v[i] 上做一些事 ...
    }

这里并未表明其意图是“单纯地”循环访问 `v` 的元素。使用一个索引的实现细节被暴露了出来（因而可能导致被误用），而且 `i` 的存在超出了循环的范围，这也许符合也许违背了设计意图。读者仅从这段代码中是无法了解清楚的。

更好的方式是：

    for (const auto& x : v) { /* 在 x 上做一些事 */ }

现在，循环机制不明确给出，而且循环的操作针对的是 `const` 元素，以防止发生意外的修改。如果需要进行修改的话，则可以这样：

    for (auto& x : v) { /* 在 x 上做一些事 */ }

有时候，使用具名的算法会更好：

    for_each(v, [](int x) { /* 在 x 上做一些事 */ });
    for_each(parallel.v, [](int x) { /* 在 x 上做一些事 */ });

最后一种写法让人明白，我们对按照何种顺序来处理 `v` 的各个元素并不关心。

程序员应当熟悉：

* [指导方针支持库](#S-gsl)
* [ISO C++ 标准库](#S-stdlib)
* 当前项目所使用的任何基础程序库

##### 注解

其他形式：说明要做什么，而不只是怎么做这些事。

##### 注解

一些语言构造比另一些可以更好地表达设计意图。

##### 示例

如果要用两个 `int` 来代表二维点的坐标值，应当这样：

      drawline(int, int, int, int);  // 含混的
      drawline(Point, Point);        // 清晰的

##### 强制实施

查找具有更加替代方案的一般模式：

* 简单 `for` 循环 vs. 范围式 `for` 循环
* `f(T*, int)` 接口 vs. `f(span<T>)` 接口
* 循环变量出现在过大的范围中
* 裸的 `new` 和 `delete`
* 带有大量内建类型参数的函数

在聪敏的人工处理和半自动的程序变换之间存在巨大的空间。

### <a name="Rp-typesafe"></a>P.4: 理想情况下，程序应当是静态类型安全的

##### 理由

理想情况下，程序应当完全是静态（编译期）类型安全的。
不幸的是，这是不可能的。有问题的领域：

* `union`
* 强制转换
* 数组衰退
* 范围错误
* 窄化转换

##### 注解

这些领域是许多严重问题（如程序崩溃和安全性违规）的来源。
我们争取为它们给出替代技术。

##### 强制实施

如果程序各自需要或者条件允许的话，我们可以逐个对这些问题类型分别进行阻止、克制或者检测。
我们总会给出替代方案。
例如：

* `union` - 使用 `variant`
* 强制转换 - 尽可能减少其使用；使用模板有助于这点
* 数组衰退 - 使用 `span`
* 范围错误 - 使用 `span`
* 窄化转换 - 尽可能减少其使用，必须使用时则使用 `narrow` 或者 `narrow_cast`

### <a name="Rp-compile-time"></a>P.5: 编译期检查优先于运行时检查

##### 理由

为了代码清晰性和性能。对于编译期捕获的错误是不需要编写错误处理的。

##### 示例

    void initializer(Int x)
    // Int 被用作整数的别名
    {
        static_assert(sizeof(Int) >= 4);    // do: 编译期检查

        int bits = 0;         // don't: avoidable code
        for (Int i = 1; i; i <<= 1)
            ++bits;
        if (bits < 32)
            cerr << "Int too small\n";

        // ...
    }

##### 示例：请避免

    void read(int* p, int n);   // 读取至多 n 个整数到 *p 之中

##### 示例

    void read(span<int> r); // 读取到整数区域范围 r 之中

**替代形式**: 不要把可以在编译期搞定的事推后到运行时进行。

##### 强制实施

* 查找指针参数。
* 查找运行时进行的范围违反检查。

### <a name="Rp-run-time"></a>P.6: 应当使无法在编译期进行的检查能够在运行时实施

##### 理由

把难于检测的错误遗留在程序中，总会带来程序崩溃或得到错误的运行结果。

##### 注解

理想情况下我们可以在编译期或者运行时捕获所有的错误（它们并非程序员的逻辑错误）。但是要在编译期捕获所有的错误是不可能的，而通常也负担不起在运行时捕获剩余的全部错误的代价。不过我们编写程序，应当尽量使其在原则上是可以在充足的（分析程序，运行时检查，机器资源，时间等）资源下进行检查的。

##### 示例，不好

    extern void f(int* p);  // 分离编译，可能会被动态加载

    void g(int n)
    {
        f(new int[n]);  // 不好的：并未把元素数量传递给 f()
    }

此处，关键性的信息（元素数量）被完全掩盖起来，使其无法进行静态分析，而如果 `f()` 属于某个 ABI 的一部分的话，由于无法对这个指针进行“测量插装”，运行时检查也是不可行的。我们确实可以在自由存储中插入有助于检查的信息，但这需要对系统甚至是编译器做出整体改动。这就是一个能让错误检查变得非常困难的设计。

##### 示例，不好

当然可以把元素数量和指针一起进行传递：

    extern void f2(int* p, int n);  // 分离编译，可能会被动态加载

    void g2(int n)
    {
        f2(new int[n], m);    // 不好的：可能会把错误的元素数量传递给 f()
    }

把元素数量作为一个参数进行传递，比只传递指针而依靠某种（不明确的）对已知元素个数的约定或者找出元素个数的方式，要好得多，而且是更加常见的做法。但是如上所示，一个简单的错字就可以引入一个严重的错误。`f2()` 的两个参数之间的关联是基于约定的，而并不明确。

而且，这里还隐含假定 `f2()` 应当 `delete` 其参数（要不然就是调用者又犯了另一个错误）。

##### 示例，不好

使用标准库的资源管理指针指向对象时，也不能传递其大小：

    extern void f3(unique_ptr<int[]>, int n);    // 分离编译，可能会被动态加载
                                                 // NB: 这里假定调用代码是 ABI 兼容的，使用的是
                                                 // 兼容的 C++ 编译器和同一个 stdlib 实现

    void g3(int n)
    {
        f3(make_unique<int[]>(n), m);    // 不好的：把所有权和大小分开进行传递
    }

##### 示例

我们得把指针和元素数量作为一个对象整体来进行传递：

    extern void f4(vector<int>&);       // 分离编译，可能会被动态加载
    extern void f4(span<int>);          // 分离编译，可能会被动态加载
                                                 // NB: 这里假定调用代码是 ABI 兼容的，使用的是
                                                 // 兼容的 C++ 编译器和同一个 stdlib 实现

    void g3(int n)
    {
        vector<int> v(n);
        f4(v);                     // 传递引用，保留所有权
        f4(span<int>{v});    // 传递视图，保留所有权
    }

这个设计将元素数量作为对象的固有部分，因此不太可能有错误，动态（运行时的）检查即使不总是可承担的，也总是可行的。

##### 示例

如果把所有权和验证所需的全部信息一起传递的话会怎么样呢？

    vector<int> f5(int n)    // OK: 移动
    {
        vector<int> v(n);
        // ... 初始化 v ...
        return v;
    }

    unique_ptr<int[]> f6(int n)    // 不好的：缺失了 n
    {
        auto p = make_unique<int[]>(n);
        // ... 初始化 *p ...
        return p;
    }

    owner<int*> f7(int n)    // 不好的：缺失了 n 并且我们可能会忘记 delete
    {
        owner<int*> p = new int[n];
        // ... 初始化 *p ...
        return p;
    }

##### 示例

* ???
* 展示传递多态基类的接口是如何避开可能进行的检查的，但它们实际上直到它们需要的类型？
  还有用字符串当作“自由式”选项的做法

##### 强制实施

* 标示出 (pointer, count) 形式的接口（这将标示出大量的因为兼容性原因而无法进行修正的实例）
* ???

### <a name="Rp-early"></a>P.7: 尽早捕获运行时错误

##### 理由

避免“神秘的”程序崩溃。
避免能够产生（也许无法识别的）错误结果的程序错误。

##### 示例

    void increment1(int* p, int n)    // 不好的：易于出错
    {
        for (int i = 0; i < n; ++i) ++p[i];
    }

    void use1(int m)
    {
        const int n = 10;
        int a[n] = {};
        // ...
        increment1(a, m);   // 可能是打错字，可能假定有 m <= n
                            // 不过让我们假设 m == 20
        // ...
    }

我们在 `use1` 里面犯了一个能够导致数据损坏或程序崩溃的小错误。
这个 (pointer, count) 形式的接口让 `increment1()` 没有可以使其防范越界错误的任何现实可行的方式。
假设我们可以检测到越界访问的下标，那么这个错误直到对 `p[10]` 进行访问之前都不会被发现。
我们可以提早进行检查来改进这个代码：

    void increment2(span<int> p)
    {
        for (int& x : p) ++x;
    }

    void use2(int m)
    {
        const int n = 10;
        int a[n] = {};
        // ...
        increment2({a, m});    // 可能是打错字，可能假定有 m<=n
        // ...
    }

现在，就可以在调用点（提早地）检查 `m<=n`，而不是更晚进行了。
如果我们只是打错了字而本想用 `n` 作为边界值的话，代码还可以进一步简化（来消除一处错误的可能性）：

    void use3(int m)
    {
        const int n = 10;
        int a[n] = {};
        // ...
        increment2(a);   // 不需要重复给出 a 的元素数量
        // ...
    }

##### 示例，不好

不要对同一个值重复进行检查。不要用字符串来传递有结构的数据：

    Date read_date(istream& is);    // 从 istream 读取日期

    Date extract_date(const string& s);    // 从 string 中抽取日期

    void user1(const string& date)    // 操作 date
    {
        auto d = extract_date(date);
        // ...
    }

    void user2()
    {
        Date d = read_date(cin);
        // ...
        user1(d.to_string());
        // ...
    }

这个日期被（`Date` 的构造函数）验证了两次，并以字符串（无结构的数据）的形式来传递。

##### 示例

过量的检查可能是代价昂贵的。
有些情况下提早检查可能是愚蠢的，因为你可能根本不需要这个值，或者可能仅需要值的一部分，而这要比进行整体的检查容易得多。同样来说，不要添加能够改变接口的渐进式行为的验证性检查（例如，不要在平均复杂度为 `O(1)` 的接口中添加一个 `O(n)` 的检查）。

    class Jet {    // 物理规则是: e*e < x*x + y*y + z*z

        float x;
        float y;
        float z;
        float e;
    public:
        Jet(float x, float y, float z, float e)
            :x(x), y(y), z(z), e(e)
        {
            // 应不应该在这里检查这些值是物理上有意义的？
        }

        float m() const
        {
            // 应不应该处理这里的退化情形？
            return sqrt(x*x + y*y + z*z - e*e);
        }

        ???
    };

喷流（Jet）的物理定律（`e*e < x*x + y*y + z*z`），由于可能存在测量误差的缘故并不是不变式。

???

##### 强制实施

* 查找指针和数组：提早进行范围检查
* 查找类型转换：消除或标示出窄化转换
* 查找未经检查的来自输入的值。
* 查找被转换成字符串的结构化数据（带有不变式的类的对象）
* ???

### <a name="Rp-leak"></a>P.8: 不要泄漏任何资源

##### 理由

即使是缓慢的资源增长，随着时间推移，也会耗尽这些资源的可用性。
这对于长时间运行的程序来说尤其重要，而且是负责任的编程行为的基础方面。

##### 示例，不好

    void f(char* name)
    {
        FILE* input = fopen(name, "r");
        // ...
        if (something) return;   // 不好的：如果 something == true 的话，将会泄漏一个文件句柄
        // ...
        fclose(input);
    }

建议采用 [RAII](#Rr-raii)：

    void f(char* name)
    {
        ifstream input {name};
        // ...
        if (something) return;   // OK: 没有泄漏
        // ...
    }

**参见**: [资源管理相关章节](#S-resource)

##### 注解

通俗地说，泄漏就是“有东西没清理干净”。一种更重要的
分类方式是“有东西无法再被清理干净”。例如，在堆上
分配一个对象，然后又丢失了最后一个指向这份分配物
的指针。不应当将这条规则误读为，要求在程序终止时
必须把长期存活的对象中的分配物进行回收。（虽然如果
它们确实可以被清理掉并进行安全地回收的话也应当这样做。）

##### 注解

强制实行[生存期剖面配置](#In.force)可以消除泄漏的发生。
如果和 [RAII](#Rr-raii) 所提供的资源安全性组合到一起，也可以（通过不产生任何垃圾而）消除对“垃圾收集”的需要。
如果将之和[类型和边界剖面配置](#In.force) 组合到一起强制实施的话，你将会得到完全的类型和资源安全性，这是通过使用工具来保证的。

##### 强制实施

* 查找指针：把它们分成非所有者（默认情形）和所有者。
  如果可行的话，把所有者替换为标准库的资源封装类（如上例所示）。
  或者，也可以把这种所有者用 [GSL](#S-gsl) 中的 `owner` 进行标记。
* 查找裸露的 `new` 和 `delete`
* 查找已知的返回原始指针的资源分配函数（诸如 `fopen`，`malloc`，和 `strdup` 等）

### <a name="Rp-waste"></a>P.9: 不要浪费时间或空间

##### 理由

你用的语言是 C++。

##### 注解

为达成某个目标（例如开发速度，资源安全性，或者测试的简化等）而正当花费的时间和空间是不会被浪费的。
“力求高效的另一种好处是，这一过程将强迫你更深入地理解问题。”—— Alex Stepanov

##### 示例，不好

    struct X {
        char ch;
        int i;
        string s;
        char ch2;

        X& operator=(const X& a);
        X(const X&);
    };

    X waste(const char* p)
    {
        if (p == nullptr) throw Nullptr_error{};
        int n = strlen(p);
        auto buf = new char[n];
        if (buf == nullptr) throw Allocation_error{};
        for (int i = 0; i < n; ++i) buf[i] = p[i];
        // ... 对缓冲区进行操作 ...
        X x;
        x.ch = 'a';
        x.s = string(n);    // 在 x.s 上预留 *ps 的空间
        for (int i = 0; i < x.s.size(); ++i) x.s[i] = buf[i];  // 把 buf 复制给 x.s
        delete buf;
        return x;
    }

    void driver()
    {
        X x = waste("Typical argument");
        // ...
    }

这个确实有些夸张，但我们在产品代码中能够见到这里所犯的每个错误，甚至更糟糕。
注意，`X` 的布局保证会浪费至少 6 个字节，而且很可能更多。
错误的复制操作的定义式废掉了移动语义，使返回操作变得更慢。
为 `buf` 使用的 `new` 和 `delete` 是多余的；如果确实想要一个局部的字符串的话，我们应当使用局部的 `string`。
还有几个其他的性能 BUG 和无理由的复杂性。

##### 示例，不好

    void lower(zstring s)
    {
        for (int i = 0; i<strlen(s); ++s) s[i] = tolower(s[i]);
    }

这个其实是一个来自产品代码的例子。
我们留给读者来找出这里浪费了什么东西。

##### 注解

单个造成浪费的范例很少是显著的，而一旦它是显著的，通常也可以被高手轻易地清除掉。
但是，代码库中放任地到处散布的浪费情况，则很容易变得显著，而高手们又不像我们期望那样总是有空的。
本条规则（以及其他配套的更加具体的规则）的目的是，将与 C++ 语言的使用有关的大多数浪费情况，在其发生之前就将之清除掉。
在这之后，我们就可以查找与算法和需求有关的浪费情况了，但这超出了我们的指导方针的范畴。

##### 强制实施

许多更加具体的规则都是针对追求简单性并清除无理由浪费的总体目标的。

### <a name="Rp-mutable"></a>P.10: 不可变数据优先于可变数据

##### 理由

对常量进行推理要比变量简单得多。
不可变的事物是不可能被意外改变的。
不可变性有时候也带来更好地进行优化的机会。
在常量上不会出现数据竞争。

另见 [Con: 常量和不可变性](#S-const)



# <a name="S-interfaces"></a>I: 接口

接口是程序中的两个部分之间的契约。严格地规定服务提供者和该服务使用者的预期是必要的。
在代码的组织中，良好的接口（易于理解，促进高效的使用方式，不易出错，支持进行测试，等等）可能是最重要的单个方面了。

接口规则概览：

* [I.1: 使接口明确](#Ri-explicit)
* [I.2: 避免全局变量](#Ri-global)
* [I.3: 避免使用单例](#Ri-singleton)
* [I.4: 使接口严格和强类型化](#Ri-typed)
* [I.5: 说明前条件（如果有）](#Ri-pre)
* [I.6: 优先使用 `Expects()` 来表达前条件](#Ri-expects)
* [I.7: 说明后条件](#Ri-post)
* [I.8: 优先使用 `Ensures()` 来表达后条件](#Ri-ensures)
* [I.9: 当接口是模板时，用概念来文档化其参数](#Ri-concepts)
* [I.10: 使用异常来表明无法实施所要求的任务](#Ri-except)
* [I.11: 决不以原始指针（`T*`）来传递所有权](#Ri-raw)
* [I.12: 把不能为空的指针声明为 `not_null`](#Ri-nullptr)
* [I.13: 不要只用一个指针来传递数组](#Ri-array)
* [I.22: 避免全局对象之间进行复杂的初始化](#Ri-global-init)
* [I.23: 保持较少的函数参数数量](#Ri-nargs)
* [I.24: 避免出现相邻而无关的相同类型的参数](#Ri-unrelated)
* [I.25: 优先以抽象类作为类层次的接口](#Ri-abstract)
* [I.26: 当想要跨编译器的 ABI 时，使用一个 C 风格的语言子集](#Ri-abi)

参见

* [F: 函数](#S-functions)
* [C.concrete: 具体类型](#SS-concrete)
* [C.hier: 类层次](#SS-hier)
* [C.over: 函数重载和重载运算符](#SS-overload)
* [C.con: 容器和其他资源封装类](#SS-containers)
* [E: 错误处理](#S-errors)
* [T: 模板和泛型编程](#S-templates)

### <a name="Ri-explicit"></a>I.1: 使接口明确

##### 理由

正确性。未在接口中规定的假设很容易被忽视而且难于测试。

##### 示例，不好

通过全局（命名空间作用域）变量（调用模式）来控制函数的行为，是隐含的，而且潜在会造成困惑。例如：

    int rnd(double d)
    {
        return (rnd_up) ? ceil(d) : d;    // 请勿：“不可见的”依赖
    }

两次调用 `rnd(7.2)` 的含义可能给出不同的结果，这对于调用者来说是不明显的。

**例外**: 我们有时候会通过环境变量来控制一组操作的细节，比如常规/详细的输出，或者调试/优化版本。
使用非局部的控制方式可能带来困惑，但可以只用来控制实现的细节，否则就只有固定的语义了。

##### 示例，不好

通过非局部变量（比如 `errno`）进行的报告经常被忽略。例如：

    fprintf(connection, "logging: %d %d %d\n", x, y, s); // 请勿：printf 的返回值未进行检查

要是连接已经关闭而导致没有产生日志输出的话会怎么样？参见 I.??。

**替代方案**: 抛出异常。异常是无法被忽略的。

**其他形式**: 避免通过非局部或者隐含的状态来跨越接口传递信息。
注意，非 `const` 的成员函数会通过对象的状态来向其他成员函数传递信息。

**其他形式**: 接口应当是函数或者一组函数集合。
函数可以是模板函数，而函数集合可以是类或者类模板。

##### 强制实施

* 【简单】 函数不能基于声明于命名空间作用域的变量来作出影响控制流的决定。
* 【简单】 函数不能对声明于命名空间作用域的变量进行写入操作。

### <a name="Ri-global"></a>I.2 避免全局变量

##### 理由

非 `const` 全局变量能够隐藏依赖关系，并使这些依赖项可能出现无法预测的变动。

##### 示例

    struct Data {
        // ... 大量成员 ...
    } data;            //  非 const 数据

    void compute()     // 请勿这样做
    {
        // ... 使用 data ...
    }

    void output()     // 请勿这样做
    {
        // ... 使用 data ...
    }

哪个可能会修改 `data` 呢？

##### 注解

全局常量是有益的。

##### 注解

针对全局变量的规则同样适用于命名空间作用域的变量。

**替代方案**: 如果你用全局数据（或者更一般地说命名空间作用域的数据）来避免复制操作的话，请考虑把数据以 const 引用的形式进行传递的方案。
另一种方案是把数据定义为某个对象的状态，而把操作定义为其成员函数。

**警告**: 请关注数据竞争：当一个线程能够访问非局部数据（或以引用传递的数据），而另一个线程执行被调用的函数时，就可能带来数据竞争。
指向可变数据的每个指针或引用都是潜在的数据竞争。

##### 注解

不可变数据是不会带来数据竞争条件的。

**参见**: 另见[关于调用函数的规则](#SS-call)。

##### 强制实施

【简单】 报告所有在命名空间作用域中声明的非 `const` 变量。

### <a name="Ri-singleton"></a>I.3: 避免使用单例

##### 理由

单例基本上就是经过伪装的更复杂的全局对象。

##### 示例

    class Singleton {
        // ... 大量代码，用于确保只创建一个 Singleton，
        // 进行正确地初始化，等等
    };

单例的想法有许多变种。
这也是问题的一方面。

##### 注解

如果不想让全局对象被改变，请将其声明为 `const` 或 `constexpr`。

##### 例外

你可以使用最简单的“单例”形式（简单到通常不被当作单例）来获得首次使用时进行初始化的效果：

    X& myX()
    {
        static X my_x {3};
        return my_x;
    }

这是解决初始化顺序相关问题的最有效方案之一。
在多线程环境中，静态对象的初始化并不会引入数据竞争条件
（除非你不小心在其构造函数中访问了某个共享对象）。

如果你和许多人一样把单例定义为只能创建一个对象的类的话，像 `myX` 这样的函数并非单例，而且这种好用的技巧并不算无单例规则的例外。

##### 强制实施

通常非常困难。

* 查找名字中包含 `singleton` 的类。
* 查找只创建一个对象的类（通过对对象计数或者检查其构造函数）。
* 如果某个类 X 具有公开的静态函数，并且它包含具有该类 X 类型的函数级局部静态变量并返回指向它的指针或者引用，就禁止它。

### <a name="Ri-typed"></a>I.4: 使接口严格和强类型化

##### 理由

类型是最简单和最好的文档，它们有定义明确的含义，并且保证在编译期进行检查。
而且，严格类型化的代码通常也能更好地进行优化。

##### 示例，请勿这样做

考虑：

    void pass(void* data);    // void* 是有问题的

被调用方必须得把数据指针强制转换（回）正确的类型以能使用它。这样做易于犯错，而且通常是多余的。
请避免 `void*`，尤其是在接口中。
请考虑使用 `variant` 或指向基类的指针来代替它。（前景注记：考虑使用指向概念的指针。）

**替代方案**: 通常，利用模板形参可以把 `void*` 排除而改为 `T*` 或者 `T&`。

##### 示例，不好

考虑：

    void draw_rect(int, int, int, int);   // 很大的犯错机会

    draw_rect(p.x, p.y, 10, 20);          // 10, 20 是什么意思？

`int` 可以携带任何形式的信息，因此我们必须猜测这四个 `int` 的含义。
前两个最可能的是坐标对 `x`,`y`，但后两个是什么呢？
注释和参数的名字可以有所帮助，但我们可以直截了当：

    void draw_rectangle(Point top_left, Point bottom_right);
    void draw_rectangle(Point top_left, Size height_width);

    draw_rectangle(p, Point{10, 20});  // 两个角点
    draw_rectangle(p, Size{10, 20});   // 一个角和一对 (height, width)

显然，我们是无法利用静态类型系统捕获所有的错误的，
例如，假定第一个参数是左上角这一点就依赖于约定（命名或者注释）。

##### 示例，不好

下例中，接口中并未明确给出 `time_to_blink` 的含义：按秒还是按毫秒算？

    void blink_led(int time_to_blink) // 不好 - 在单位上含糊
    {
        // ...
        // 对 time_to_blink 做一些事
        // ...
    }

    void use()
    {
        blink_led(2);
    }

##### 示例，好

C++11 所引入的 `std::chrono::duration` 类型可以让时间段的单位明确下来。

    void blink_led(milliseconds time_to_blink) // 好 - 单位明确
    {
        // ...
        // 对 time_to_blink 做一些事
        // ...
    }

    void use()
    {
        blink_led(1500ms);
    }

这个函数还可以写成使其接受任何时间段单位的形式。

    template<class rep, class period>
    void blink_led(duration<rep, period> time_to_blink) // 好 - 接受任何单位
    {
        // 假设最小的有意义单位是毫秒
        auto milliseconds_to_blink = duration_cast<milliseconds>(time_to_blink);
        // ...
        // 对 milliseconds_to_blink 做一些事
        // ...
    }

    void use()
    {
        blink_led(2s);
        blink_led(1500ms);
    }

##### 强制实施

* 【简单】 报告将 `void*` 用作参数或返回类型的情况
* 【难于做好】 查找带有许多内建类型的参数的成员函数。

### <a name="Ri-pre"></a>I.5: 说明前条件（如果有）

##### 理由

在参数上蕴含着使它们在被调用方中能够恰当使用的约束关系。

##### 示例

考虑：

    double sqrt(double x);

这里 `x` 必须是非负数。类型系统是无法（简洁并自然地）表达这点的，因而我们得用别的方法。例如：

    double sqrt(double x); // x 必须是非负数

一些前条件可以表示为断言。例如：

    double sqrt(double x) { Expects(x >= 0); /* ... */ }

理想情况下，这个 `Expects(x >= 0)` 应当是 `sqrt()` 的接口的一部分，但我们无法轻易做到这点。当前，我们将之放入定义式（函数体）之中。

**参考**: `Expects()` 在 [GSL](#S-gsl) 中有说明。

##### 注解

优先使用正式的必要条件说明，比如 `Expects(p != nullptr);`。如果这样不可行，就在注释中使用文字来说明，比如
`// 序列 [p:q) 根据 < 排序`。

##### 注解

许多成员函数都以某个类所保持的不变式作为一项前条件。
这个不变式是由构造函数所建立的，且必须在被从类之外所调用的每个成员函数的退出时重新建立。
我们并不需要对每个成员函数都说明这个不变式。

##### 强制实施

【无法强制实施】

**参见**: 有关传递指针的规则。???

### <a name="Ri-expects"></a>I.6: 优先使用 `Expects()` 来表达前条件

##### 理由

清晰地表明这个条件是一个前条件，并便于工具的利用。

##### 示例

    int area(int height, int width)
    {
        Expects(height > 0 && width > 0);            // 好
        if (height <= 0 || width <= 0) my_error();   // 隐晦的
        // ...
    }

##### 注解

前条件是可以用许多方式来说明的，包括代码注释，`if` 语句，以及 `assert()`。这些方式使其难于与普通代码之间进行区分，难于进行更新，难于利用工具来操作，而且可能具有错误的语义（你真的总是想要在调试模式中止程序而在生产运行中不做任何检查吗？）

##### 注解

前条件应当是接口的一部分，而不是实现的一部分，但我们至今还没有能够做到这点的语言设施。

##### 注解

`Expects()` 还可以用于在算法的中部来检查某个条件。

##### 强制实施

【无法强制实施】 要把各种对前条件进行断言的方式都找出来是不可行的。对那些易于识别的（如 `assert()`）实例给出警告的做法，其意义在缺少语言设施的前提下是有问题的。

### <a name="Ri-post"></a>I.7: 说明后条件

##### 理由

以检测到对返回结果的误解，还可能发现实现中存在错误。

##### 示例，不好

考虑：

    int area(int height, int width) { return height * width; }  // 不好

这里，我们（粗心大意地）遗漏了前条件的说明，因此高度和宽度必须是正数这点是不明确的。
我们也遗漏了后条件的说明，因此算法（`height * width`）对于大于最大整数的面积来说是错误的这点是不明显的。
可能会有溢出。
应该考虑使用：

    int area(int height, int width)
    {
        auto res = height * width;
        Ensures(res > 0);
        return res;
    }

##### 示例，不好

考虑一个著名的安全性 BUG：

    void f()    // 有问题的
    {
        char buffer[MAX];
        // ...
        memset(buffer, 0, MAX);
    }

由于没有后条件来说明缓冲区应当被清零，优化器可能会将这个看似多余的 `memset()` 调用给清除掉：

    void f()    // 有改进
    {
        char buffer[MAX];
        // ...
        memset(buffer, 0, MAX);
        Ensures(buffer[0] == 0);
    }

##### 注解

后条件通常是在说明函数目的的代码注释中非正式地进行说明的；用 `Ensures()` 可以使之更加系统化，更加明显，并且更容易检查。

##### 注解

后条件对于那些无法在所返回的结果中直接体现的东西来说尤其重要，比如要说明所用的数据结构。

##### 示例

考虑一个操作 `Record` 的函数，它使用 `mutex` 来避免数据竞争条件：

    mutex m;

    void manipulate(Record& r)    // 请勿这样做
    {
        m.lock();
        // ... 没有 m.unlock() ...
    }

这里，我们“忘记”说明应当释放 `mutex`，因此我们搞不清楚这里 `mutex` 释放的缺失是一个 BUG 还是一种功能特性。
把后条件说明将使其更加明确：

    void manipulate(Record& r)    // 后条件: m 在退出后是未锁定的
    {
        m.lock();
        // ... 没有 m.unlock() ...
    }

现在这个 BUG 就明显了（但仅对阅读了代码注释的人类来说）。

更好的做法是使用 [RAII](#Rr-raii) 来在代码中保证后条件（“锁必须进行释放”）的实施：

    void manipulate(Record& r)    // 最好这样
    {
        lock_guard<mutex> _ {m};
        // ...
    }

##### 注解

理想情况下，后条件应当在接口或声明式中说明，让使用者易于见到它们。
只有那些与使用者有关的后条件才应当在接口中说明。
仅与内部状态相关的后条件应当属于定义式或实现。

##### 强制实施

【无法强制实施】 这是一条理念性的指导方针，一般情况下进行直接的
检查是不可行的。不过许多工具链中都有适用于特定领域的检查器，
比如针对锁定持有情况的检查器。

### <a name="Ri-ensures"></a>I.8: 优先使用 `Ensures()` 来表达后条件

##### 理由

清晰地表明这个条件是一个后条件，并便于工具的利用。

##### 示例

    void f()
    {
        char buffer[MAX];
        // ...
        memset(buffer, 0, MAX);
        Ensures(buffer[0] == 0);
    }

##### 注解

后条件是可以用许多方式来说明的，包括代码注释，`if` 语句，以及 `assert()`。这些方式使其难于与普通代码之间进行区分，难于进行更新，难于利用工具来操作，而且可能具有错误的语义。

**替代方案**: 如“这个资源必须被释放”这样形式的后条件最好以 [RAII](#Rr-raii) 的方式来表达。

理想情况下，`Ensures` 应当是接口的一部分，但我们无法轻易做到这点。当前，我们将之放入定义式（函数体）之中。

##### 强制实施

【无法强制实施】 要把各种对后条件进行断言的方式都找出来是不可行的。对那些易于识别的（如 `assert()`）实例给出警告的做法，其意义在缺少语言设施的前提下是有问题的。

### <a name="Ri-concepts"></a>I.9: 当接口是模板时，用概念来文档化其参数

##### 理由

更严谨地说明接口，并使其在（不远的）将来可以在编译时进行检查。

##### 示例

使用 ISO Concepts TS 风格的必要条件说明。例如：

    template<typename Iter, typename Val>
    // requires InputIterator<Iter> && EqualityComparable<ValueType<Iter>>, Val>
    Iter find(Iter first, Iter last, Val v)
    {
        // ...
    }

##### 注解

很快（可能是 2016 年），大多数编译器就有能力检查删除了 `//` 之后的 `requires` 子句了。

**参见**: 另见[泛型编程](#SS-GP)和[概念](#SS-t-concepts)。

##### 强制实施

【还无法强制实施】 当前正在对一种语言设施进行规范化。一旦这种语言设施出现，就可以对未被概念所约束（在其声明式之中或者在一个 `requires` 子句中所给出）的并非可变数量的模板形参作出警告了。

### <a name="Ri-except"></a>I.10: 使用异常来表明无法实施所要求的任务

##### 理由

不应该让错误可以被忽略，因为这将导致系统或者一次运算进入未定义的（或者预料之外的）状态。
这是错误的一个主要来源。

##### 示例

    int printf(const char* ...);    // 不好: 当输出失败时返回负值

    template <class F, class ...Args>
    explicit thread(F&& f, Args&&... args);    // 好: 当无法启动一个新的线程时抛出 system_error

##### 注解： 错误是什么？

错误的含义是函数无法达成其所宣称的目标（这包括后条件的建立）。
把错误忽略掉的调用方代码将导致错误的结果，或者未定义的系统状态。
例如，无法连接一个远程服务器本身并不是错误：
这个服务器可以因为各种原因而拒绝连接，因此合乎常理的方式是让其返回一个其调用者必然要检查的结果。
不过，如果无法连接本身就是被当作一种错误的话，这个失败时应当抛出一个异常。

**例外**: 许多传统的接口函数（比如 UNIX 的信号处理器）都使用错误代码（就是 `errno`）来报告其实是状态代码而不是错误的东西。你没有更好的选择只能用它，因此对其调用并不违反本条规则。

**替代方案**: 如果你不能使用异常（比如说由于你的代码全都是老式的原始指针用法，或者由于你有硬实时性的约束），请考虑使用返回一对值的代码风格：

    int val;
    int error_code;
    tie(val, error_code) = do_something();
    if (error_code == 0) {
        // ... 处理错误或者退出 ...
    }
    // ... 使用 val ...

##### 注解

我们并不认为“性能”是一种不使用异常的合理理由。

* 通常，显式的错误检查和处理会消耗掉和异常处理一样多的时间和空间。
* 通常，使用异常的更清晰的代码会带来更好的性能（简化了对程序执行路径的追踪和其优化）。
* 一条对性能关键代码的好规则是，把检查从代码的关键部分中移出去（[检查](#Rper-checking)）。
* 长期来看，更规整的代码会得到更好的优化。

**参见**: [I.5](#Ri-pre) 和 [I.7](#Ri-post) 有关报告前条件和后条件的违反。

##### 强制实施

* 【无法强制实施】 这是一条理念性的指导方针，进行直接的检查是不可行的。
* 查找 `errno`。

### <a name="Ri-raw"></a>I.11: 决不以原始指针（`T*`）来传递所有权

##### 理由

如果对调用者和被调用方哪一个拥有对象有疑问，那就会造成泄漏或者发生提早的析构。

##### 示例

考虑：

    X* compute(args)    // 请勿这样做
    {
        X* res = new X{};
        // ...
        return res;
    }

应当由谁来删除返回的这个 `X` 呢？如果 `compute` 返回引用的话这个问题将更难发现。
应该考虑按值来返回结果（如果结果比较大的话就用移动语义）：

    vector<double> compute(args)  // 好的
    {
        vector<double> res(10000);
        // ...
        return res;
    }

**替代方案**: 用“智能指针”来传递所有权，比如 `unique_ptr`（专有所有权）和 `shared_ptr`（共享所有权）。
不过除非你需要引用语义，否则这样做并没有那么简炼和高效。

**替代方案**: 有时候因为 ABI 兼容性的要求或者缺少资源，是无法对老代码进行修改的。
这种情况下，请用 `owner` 来标记拥有对象的指针：

    owner<X*> compute(args)    // 现在就明确传递了所有权这一点
    {
        owner<X*> res = new X{};
        // ...
        return res;
    }

这告诉了分析工具 `res` 是一个所有者。
就是说，它的值必须被 `delete`，或者被传递给另一个所有者，正如这里的 `return` 所做。

在资源包装类的实现中也同样使用了 `owner`。

`owner` 定义于[指导方针支持库](#S-gsl)之中。

##### 注解

以原始指针（或迭代器）的形式传递的对象，都假定是由调用方
所有的，因此其生存期也由调用方来处理。换种方式来看：
传递所有权的 API 相对于传递指针的 API 来说比较少见，
因此缺省情况就是“不传递所有权”。

**参见**: [实参传递](#Rf-conventional)和[返回值](#Rf-T-return)。

##### 强制实施

* 【简单】 当对并非 `owner` 的原始指针进行 `delete` 就发出警告。
* 【简单】 当任何代码路径上遗漏了对 `owner` 指针的 `reset` 或者显式的 `delete` 时就发出警告。
* 【简单】 当把 `new` 或者返回值为指针类型的函数的返回值赋值给原始指针时就发出警告。

### <a name="Ri-nullptr"></a>I.12: 把不能为空的指针声明为 `not_null`

##### 理由

帮助避免对 `nullptr` 解引用的错误。通过避免多余的 `nullptr` 检查来提高性能。

##### 示例

    int length(const char* p);            // 不清楚 length(nullptr) 是否有效

    length(nullptr);                      // OK?

    int length(not_null<const char*> p);  // 有改善：可以假定 p 不可能为 nullptr

    int length(const char* p);            // 只好假定 p 可以为 nullptr

通过在源代码中说明意图，实现者和工具就可以提供更好的诊断能力，比如通过静态分析来找出某些种类的错误，还可以实施优化，比如移除分支和空值测试。

##### 注解

指向 `char` 的指针将指向 C 风格的字符串（以零终结的字符的连续串）这一点仍然是潜规则，并且也是混乱和错误的潜在来源。请使用 `zstring` 来代替 `const char*`。

    int length(not_null<zstring> p);   // 可以假定 p 不能为 nullptr
                                       // 可以假定 p 指向以零终结的字符数组

注意： `length()` 显然是经过伪装的 `std::strlen()`。

##### 强制实施

* 【简单】〔基础〕 如果有函数在所有控制流路径上访问指针参数之前检查它是否是 `nullptr`，则给出警告称其应当被声明为 `not_null`。
* 【复杂】 如果有指针返回值的函数在所有返回路径上都保证其不是 `nullptr`，则给出警告称返回类型应当被声明为 `not_null`。

### <a name="Ri-array"></a>I.13: 不要只用一个指针来传递数组

##### 理由

 (pointer, size) 式的接口是易于出错的。同样，（指向数组的）普通指针还必须依赖某种约定以使被调用方来确定其大小。

##### 示例

考虑：

    void copy_n(const T* p, T* q, int n); // 从 [p:p+n) 复制到 [q:q+n)

当由 `q` 所指向的数组少于 `n` 个元素会怎么样？此时我们将覆写一些可能无关的内存。
当由 `p` 所指向的数组少于 `n` 个元素会怎么样？此时我们将读取一些可能无关的内存。
次二者都是未定义的行为，而且可能是非常恶劣的 BUG。

##### 替代方案

考虑使用明确的 `span`：

    void copy(span<const T> r, span<T> r2); // 将 r 复制给 r2

##### 示例，不好

考虑：

    void draw(Shape* p, int n);  // 糟糕的接口；糟糕的代码
    Circle arr[10];
    // ...
    draw(arr, 10);

把 `10` 作为参数 `n` 传递可能是错误的：虽然最常见的约定是假定有 [`0`:`n`)，但这点并未不是明确的。更糟糕的是，`draw()` 的调用通过编译了：这里有一次从数组到指针的隐式转换（数组衰退），然后又进行了从 `Circle` 到 `Shape` 的另一次隐式转换。`draw()` 是不可能安全地迭代这个数组的：它无法知道元素的大小。

**替代方案**: 使用一个辅助类来确保元素的数量正确，并避免进行危险的隐式转换。例如：

    void draw2(span<Circle>);
    Circle arr[10];
    // ...
    draw2(span<Circle>(arr));  // 推断出元素的数量
    draw2(arr);    // 推断出元素的类型和数组大小

    void draw3(span<Shape>);
    draw3(arr);    // 错误: 无法将 Circle[10] 转换为 span<Shape>

这个 `draw2()` 传递了与 `draw()` 同样数量的信息，但明确指定了它接受的是 `Circle` 的范围。参见 ???.

**例外**: 使用 `zstring` 和 `czstring` 来表示 C 风格的以零终结字符串。
但这样做时，应当使用 (GSL)[#GSL] 中的 `string_span` 以避免范围错误。

##### 强制实施

* 【简单】〔边界〕 对任何依赖于从数组类型向指针类型的隐式转换的表达式给出警告。允许 zstring/czstring 指针类型的例外。
* 【简单】〔边界〕 对任何指针类型表达式进行且结果为指针类型的值的运算操作给出警告。允许 zstring/czstring 指针类型的例外。


### <a name="Ri-global-init"></a>I.22: 避免全局对象之间进行复杂的初始化

##### 理由

复杂的初始化可能导致未定义的执行顺序。

##### 示例

    // file1.c

    extern const X x;

    const Y y = f(x);   // 读取 x; 写入 y

    // file2.c

    extern const Y y;

    const X x = g(y);   // 读取 y; 写入 x

由于 `x` 和 `y` 是处于不同翻译单元之内的，调用 `f()` 和 `g()` 的顺序就是未定义的；
我们可能会访问到还未初始化的 `const` 对象。
这个特别的例子展示了，全局（命名空间作用域）对象的初始化顺序难题并不仅限于全局*变量*而已。

##### 注解

并发代码中的初始化顺序问题是更加难于处理的。
所以通常最好完全避免使用全局（命名空间作用域）的对象。

##### 强制实施

* 标记调用了非 `constexpr` 函数的全局初始化式
* 标记访问了 `extern` 对象的全局初始化式

### <a name="Ri-nargs"></a>I.23: 保持较少的函数参数数量

##### 理由

大量参数会带来更大的出现混乱的机会。大量传递参数与其他替代方案相比也通常是代价比较大的。

##### 示例

标准库的 `merge()` 函数达到了我们可以自如处理的界限

    template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2,
                         OutputIterator result, Compare comp);

其中有四个模板参数和留个函数参数。
为简化最常用和最简单的用法，比较器参数可以缺省使用 `<`：

    template<class InputIterator1, class InputIterator2, class OutputIterator>
    OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2,
                         OutputIterator result);

这实际上不会减低其整体复杂性，但它减少了对于许多使用者的表面复杂性。
为了真正地减少参数的数量，我们得把参数归拢到更高层的抽象之中：

    template<class InputRange1, class InputRange2, class OutputIterator>
    OutputIterator merge(InputRange1 r1, InputRange2 r2, OutputIterator result);

把参数成“批”进行组合是减少参数数量和增加进行检查的机会的一般性技巧。

##### 注解

多少参数算很多？四个已经不少了。
有些函数确实最好表现为四个独立的参数，但这样的函数并不多。

**替代方案**: 把参数归集为由意义的对象，然后（按值或按引用）传递这些对象。

**替代方案**: 利用默认实参或者重载来让最常见的调用方式可以用比较少的实参来进行。

##### 强制实施

* 当函数声明了两个类型相同的迭代器（也包括指针）而不是一个范围或视图，就给出警告。
* 【无法强制实施】 这是一条理念性的指导方针，进行直接的检查是不可行的。

### <a name="Ri-unrelated"></a>I.24: 避免出现相邻而无关的相同类型的参数

##### 理由

相同类型的相邻参数很容易被不小心互换掉。

##### 示例，不好

考虑：

    void copy_n(T* p, T* q, int n);  // 从 [p:p+n) 复制到 [q:q+n)

这是个 K&R C 风格接口的一种恶劣的变种。它导致很容易把“目标”和“来源”参数搞反。

可以在“来源”参数上使用 `const`：

    void copy_n(const T* p, T* q, int n);  // 从 [p:p+n) 复制到 [q:q+n)

##### 示例

当参数的顺序不重要时，不会造成问题：

    int max(int a, int b);

##### 替代方案

不要以指针来传递数组，而要传递用来表示一个范围的对象（比如一个 `span`）：

    void copy_n(span<const T> p, span<T> q);  // 从 p 复制到 q

##### 替代方案

定义一个结构体来作为参数类型，并依照各个参数来命名它的各字段：

    struct SystemParams {
        string config_file;
        string output_path;
        seconds timeout;
    };
    void initialize(SystemParams p);

这样做带来一种使其调用代码对于以后的读者变得明晰的倾向，因为这种参数
在调用点通常都要按名字来进行填充。

##### 强制实施

【简单】 当两个连续的参数具有相同的类型时就给出警告。

### <a name="Ri-abstract"></a>I.25: 优先以抽象类作为类层次的接口

##### 理由

抽象类要比带有状态的基类更倾向于保持稳定。

##### 示例，不好

你知道 `Shape` 总会冒出来的 :-)

    class Shape {  // 不好: 接口类中加载了数据
    public:
        Point center() const { return c; }
        virtual void draw() const;
        virtual void rotate(int);
        // ...
    private:
        Point c;
        vector<Point> outline;
        Color col;
    };

这将强制性要求每个派生类都要计算出一个中心点——即使这并不容易，而且这个中心点从不会被用到。相似地说，不是每个 `Shape` 都有一个 `Color`，而许多 `Shape` 也最好别用一个定义成一系列 `Point` 的轮廓来进行表示。抽象类就是为了防止人们编写这样的类而创造出来的：

    class Shape {    // 有改进: Shape 是一个纯接口
    public:
        virtual Point center() const = 0;   // 纯虚函数
        virtual void draw() const = 0;
        virtual void rotate(int) = 0;
        // ...
        // ... 没有数据成员 ...
    };

##### 强制实施

【简单】 如果指向 `C` 类的指针被赋值给一个指向 `C` 的基类的指针，而这个基类包含数据成员时，就给出警告。

### <a name="Ri-abi"></a>I.26: 当想要跨编译器的 ABI 时，使用一个 C 风格的语言子集

##### 理由

不同的编译器会实现不同的类的二进制布局，异常处理，函数名字，以及其他的实现细节。

**例外**: 你可以使用少量精心选择的高层次 C++ 类型来精心制造出一种接口。参见 ???。

**例外**: 在一些平台上正有公共的 ABI 兴起，这可以使你从更加苛刻的限制中摆脱出来。

##### 注解

如果你只用一种编译器，你也可以在接口上使用完全的 C++。但当升级到新的编译器版本之后，可能需要进行重新编译。

##### 强制实施

【无法强制实施】 要可靠地识别某个接口是否是构成 ABI 的一部分是很困难的。

# <a name="S-functions"></a>F: 函数

函数指定了一个活动或者一次计算，以将系统从一种一致的状态转移到另一种一致的状态。函数是程序的基础构造块。

应当使函数的名字有意义，说明对其参数的必要条件，并清晰地规定参数和其结果之间的关系。函数的实现本身并不是规格说明。请尝试同时对函数应当做什么和函数应当怎样做来进行思考。
函数在大多数接口中都是最关键的部分，请参考接口的规则。

函数规则概览：

函数定义式的规则：

* [F.1: 把有意义的操作“打包”成为精心命名的函数](#Rf-package)
* [F.2: 一个函数应当实施单一一项逻辑操作](#Rf-logical)
* [F.3: 保持函数短小简洁](#Rf-single)
* [F.4: 如果函数必须在编译期进行求值，就将其声明为 `constexpr`](#Rf-constexpr)
* [F.5: 如果函数非常小，并且是时间敏感的，就将其声明为 `inline`](#Rf-inline)
* [F.6: 如果函数不会抛出异常，就将其声明为 `noexcept`](#Rf-noexcept)
* [F.7: 对于常规用法，应当接受 `T*` 或 `T&` 参数而不是智能指针](#Rf-smart)
* [F.8: 优先采用纯函数](#Rf-pure)

参数传递表达式的规则：

* [F.15: 优先采用简单的和传统的信息传递方式](#Rf-conventional)
* [F.16: 对于“输入（in）”参数，把复制操作廉价的类型按值进行传递，把其他类型按 `const` 引用进行传递](#Rf-in)
* [F.17: 对于“输入/输出（in-out）”参数，按非 `const` 引用进行传递](#Rf-inout)
* [F.18: 对于“消耗（consume）”参数，按 `X&&` 进行传递并对参数 `std::move`](#Rf-consume)
* [F.19: 对于“转发（forward）”参数，按 `TP&&` 进行传递并只对参数 `std::forward`](#Rf-forward)
* [F.20: 对于“输出（out）”值，采用返回值优先于输出参数](#Rf-out)
* [F.21: 要返回多个“输出”值，优先返回元组（tuple）或结构体](#Rf-out-multi)
* [F.60: 当“没有参数”是有效的选项时，采用 `T*` 优先于 `T&`](#Rf-ptr-ref)

参数传递语义的规则：

* [F.22: 用 `T*`，`owner<T*>` 或者智能指针来代表一个对象](#Rf-ptr)
* [F.23: 用 `not_null<T>` 来表明“空值（null）”不是有效的值](#Rf-nullptr)
* [F.24: 用 `span<T>` 或者 `span_p<T>` 来代表一个半开序列](#Rf-range)
* [F.25: 用 `zstring` 或者 `not_null<zstring>` 来代表 C 风格的字符串](#Rf-string)
* [F.26: 当需要指针时，用 `unique_ptr<T>` 来传递所有权](#Rf-unique_ptr)
* [F.27: 用 `shared_ptr<T>` 来共享所有权](#Rf-shared_ptr)

值返回语义的规则：

* [F.42: 返回 `T*` 来（仅仅）给出一个位置](#Rf-return-ptr)
* [F.43: 不要（直接或间接）返回指向局部对象的指针](#Rf-dangle)
* [F.44: 当不想进行复制，而“没有对象被返回”不是有效的选项时，返回 `T&`](#Rf-return-ref)
* [F.45: 不要返回 `T&&`](#Rf-return-ref-ref)
* [F.46: `int` 是 `main()` 的返回类型](#Rf-main)
* [F.47: 赋值运算符返回 `T&`](#Rf-assignment-op)

其他函数规则：

* [F.50: 当函数不适用时（不能俘获局部变量，或者不能编写局部函数），就使用 Lambda](#Rf-capture-vs-overload)
* [F.51: 如果需要作出选择，采用默认实参应当优先于进行重载](#Rf-default-args)
* [F.52: 对于局部使用的（也包括传递给算法的）lambda，优先采用按引用俘获](#Rf-reference-capture)
* [F.53: 对于非局部使用的（包括被返回的，在堆上存储的，或者传递给别的线程的）lambda，避免采用按引用俘获](#Rf-value-capture)
* [F.54: 当俘获了 `this` 时，显式俘获所有的变量（不使用默认俘获）](#Rf-this-capture)

函数和 Lambda 表达式以及函数对象有很强的相似性，请参见章节 ???。

## <a name="SS-fct-def"></a>F.def: 函数的定义式

函数的定义式就是一并指定了函数的实现（函数体）的函数声明式。

### <a name="Rf-package"></a>F.1: 把有意义的操作“打包”成为精心命名的函数

##### 理由

把公共的代码分解出去，将使代码更易于阅读，更可能被重用，并能够对源于复杂代码的错误有所限制。
如果某部分是一个明确指定的活动，就将之从其包围代码中分离出来，并为其进行命名。

##### 示例，请勿这样做

    void read_and_print(istream& is)    // 读取并打印一个 int
    {
        int x;
        if (is >> x)
            cout << "the int is " << x << '\n';
        else
            cerr << "no int on input\n";
    }

`read_and_print` 的几乎每件事都有问题。
它进行了读取，它（向一个固定 `ostream`）进行了写入，它（向一个固定的 `ostream`）写入了错误消息，它只能处理 `int`。
这里没有可以重用的东西，逻辑上分开的操作被搅拌到了一起，而局部变量在其逻辑上使用完毕之后仍处于作用域中。
作为一个小例子的话还好，但如果输入操作、输出操作和错误处理更加复杂的话，
这个纠缠混乱的代码就会变得难于理解了。

##### 注解

如果你编写的一个有些价值的 lambda 可能潜在地被用于多处，那就为它进行命名并将其赋值给一个（通常非局部的）变量。

##### 示例

    sort(a, b, [](T x, T y) { return x.rank() < y.rank() && x.value() < y.value(); });

对 lambda 进行命名，将会把这个表达式进行逻辑上的分解，还会为 lambda 的含义给出有力的提示。

    auto lessT = [](T x, T y) { return x.rank() < y.rank() && x.value() < y.value(); };

    sort(a, b, lessT);
    find_if(a, b, lessT);

对于性能和可维护性来说，最简短的代码并不总是最好的选择。

**例外**: 循环体，包括用作循环体的 lambda，很少需要进行命名。
然而，大型的循环体（比如好多行或者好多页）也是个问题。
规则“[保持函数短小简洁](#Rf-single)”暗含有“保持循环体短小”。
与此相似，用作回调参数的 lambda 有事后也是有意义的，虽然它们不大可能被重用。

##### 强制实施

* 参见“[保持函数短小简洁](#Rf-single)”
* 把不同地方所用的同样和非常相似的 lambda 标记出来。

### <a name="Rf-logical"></a>F.2: 一个函数应当实施单一一项逻辑操作

##### 理由

仅实施单一操作的函数易于理解，测试和重用。

##### 示例

考虑：

    void read_and_print()    // 不好
    {
        int x;
        cin >> x;
        // 检查错误
        cout << x << "\n";
    }

这是一整块被绑定到一个特定的输入的代码，而且无法为其找到另一种（不同的）用途。作为代替，我们把函数分解为合适的逻辑部分并进行参数化：

    int read(istream& is)    // 有改进
    {
        int x;
        is >> x;
        // 检查错误
        return x;
    }

    void print(ostream& os, int x)
    {
        os << x << "\n";
    }

这样的话，就可以在需要时进行组合：

    void read_and_print()
    {
        auto x = read(cin);
        print(cout, x);
    }

如果有需要，我们还可以进一步把 `read()` 和 `print()` 针对数据类型，I/O 机制，以及对错误的反应等等方面进行模板化。例如：

    auto read = [](auto& input, auto& value)    // 有改善
    {
        input >> value;
        // 检查错误
    };

    auto print(auto& output, const auto& value)
    {
        output << value << "\n";
    }

##### 强制实施

* 把具有多个“输出”参数的函数当作有问题的。使用返回值来代替，包括以 `tuple` 用作多个返回值。
* 把无法装入编辑器的一屏之内的“大型”函数当作有问题的。考虑把这种函数分解为较小的恰当命名的子操作。
* 把有七个或更多参数的函数当作有问题的。

### <a name="Rf-single"></a>F.3: 保持函数短小简洁

##### 理由

大型函数难于阅读，更有可能包含复杂的代码，而且更有可能含有其作用域超过最低限度的变量。
带有复杂的控制结构的函数更有可能变长，也更有可能隐藏逻辑错误于其中。

##### 示例

考虑：

    double simpleFunc(double val, int flag1, int flag2)
        // simpleFunc: 接受一个值并计算所需的 ASIC 值，依赖于两个模式标记。
    {

        double intermediate;
        if (flag1 > 0) {
            intermediate = func1(val);
            if (flag2 % 2)
                 intermediate = sqrt(intermediate);
        }
        else if (flag1 == -1) {
            intermediate = func1(-val);
            if (flag2 % 2)
                 intermediate = sqrt(-intermediate);
            flag1 = -flag1;
        }
        if (abs(flag2) > 10) {
            intermediate = func2(intermediate);
        }
        switch (flag2 / 10) {
            case 1: if (flag1 == -1) return finalize(intermediate, 1.171); break;
            case 2: return finalize(intermediate, 13.1);
            default: ;
        }
        return finalize(intermediate, 0.);
    }

这个函数过于复杂了（也相当长）。
要如何判断是否所有的可能性都被正确处理了呢？
当然，它也同样违反了别的规则。

我们可以进行重构：

    double func1_muon(double val, int flag)
    {
        // ???
    }

    double funct1_tau(double val, int flag1, int flag2)
    {
        // ???
    }

    double simpleFunc(double val, int flag1, int flag2)
        // simpleFunc: 接受一个值并计算所需的 ASIC 值，依赖于两个模式标记。
    {
        if (flag1 > 0)
            return func1_muon(val, flag2);
        if (flag1 == -1)
            return func1_tau(-val, flag1, flag2);    // 由 func1_tau 来处理: flag1 = -flag1;
        return 0.;
    }

##### 注解

“无法放入一屏显示”通常是对“太长了”的一种不错的实际定义方式。
一行到五行大小的函数应当被当作是常态。

##### 注解

把大型函数分解成较小的紧致的有名字的函数。
小型的简单函数在函数调用的代价比较明显时很容易被内联。

##### 强制实施

* 标记无法“放入一屏”的函数。
  一屏有多大？可以试试 60 行，每行 140 个字符；这大致上就是书本页面能够适于阅读的最大值了。
* 标记过于复杂的函数。多复杂算是过于复杂呢？
  应当用圈复杂度来度量。可以试试“多于 10 个逻辑路径”。一个简单的开关算作一条路径。

### <a name="Rf-constexpr"></a>F.4: 如果函数必须在编译期进行求值，就将其声明为 `constexpr`

##### 理由

需要用 `constexpr` 来告诉编译器允许对其进行编译期求值。

##### 示例

（不）著名的阶乘例子：

    constexpr int fac(int n)
    {
        constexpr int max_exp = 17;      // constexpr 让其可以在 Expects 中使用
        Expects(0 <= n && n < max_exp);  // 防止犯糊涂和发生溢出
        int x = 1;
        for (int i = 2; i <= n; ++i) x *= i;
        return x;
    }

这个是 C++14。对于 C++11，请使用递归形态的 `fac()`。

##### 注解

`constexpr` 并不会保证发生编译期求值；
它只能保证函数可以在当程序员需要或者编译器为优化而决定时，对常量表达式实参进行编译期求值。

    constexpr int min(int x, int y) { return x < y ? x : y; }

    void test(int v)
    {
        int m1 = min(-1, 2);            // 可能进行编译期求值
        constexpr int m2 = min(-1, 2);  // 编译期求值
        int m3 = min(-1, v);            // 运行期求值
        constexpr int m4 = min(-1, v);  // 错误: 无法在编译期求值
    }

##### 注解

`constexpr` 函数都是纯函数：它们不能有副作用。

    int dcount = 0;
    constexpr int double(int v)
    {
        ++dcount;   // 错误：试图在 constexpr 函数中产生副作用
        return v + v;
    }

通常这样是很棒的。

##### 注解

不要试图让所有函数都变成 `constexpr`。大多数计算都最好在运行时进行。

##### 注解

任何可能最终将依赖于高层次的运行时配置或者
业务逻辑的API，都不应当是 `constexpr` 的。这种定制化是无法
由编译期来求值的，并且依赖于这种 API 的任何 `constexpr` 函数
也都应当进行重构，或者抛弃掉 `constexpr`。

##### 强制实施

不可能也不必要。
当在要求常量的地方调用了非 `constexpr` 函数时，编译器会报告错误。

### <a name="Rf-inline"></a>F.5: 如果函数非常小，并且是时间敏感的，就将其声明为 `inline`

##### 理由

有些优化器可以不依赖于程序员的提示就能很好地进行内联，但请不要依赖这点。
请测量！至少超过 40 年，我们一直在允诺编译器可以不依赖于人类的提示而做到比人类更好地内联。
可是我们还在等。
给出 `inline` 能够促进编译器更好地工作。

##### 示例

    ???

**例外**: 不要把 `inline` 函数加入需要变得稳定的接口中，除非你十分确定它不会再发生变化。
内联函数是 ABI的一部分。

##### 注解

`constexpr` 蕴含 `inline`。

##### 注解

在类之中所定义的成员函数默认是 `inline` 的。

**例外**: 模板函数（包括模板成员函数）必须处于头文件中，因此是内联的。

##### 强制实施

对超过三条语句，并且本可以声明为非内联的 `inline` 函数（比如类成员函数）进行标记 `inline`。
修正：将函数声明为非内联的。（NM: 这当然是可以做到的，不过基于大小的测量可能会让人不快。）

### <a name="Rf-noexcept"></a>F.6: 如果函数不会抛出异常，就将其声明为 `noexcept`

##### 理由

如果不打算抛出异常的话，程序就会认为无法处理这种错误，并且应当尽早终止。把函数声明为 `noexcept` 对优化器有好处，因为其减少了可能的执行路径的数量。它也能使发生故障之后的退出动作有所加速。

##### 示例

给完全以 C 或者其他任何没有异常的语言编写的每个函数都标上 `noexcept`。
C++ 标准库隐含地对 C 标准库中的所有函数做了这件事。

##### 注解

`constexpr` 函数不会抛出异常，因此并不需要为它们使用 `noexcept`。

##### 示例

对能够抛出异常的函数也可以使用 `noexcept`：

    vector<string> collect(istream& is) noexcept
    {
        vector<string> res;
        for (string s; is >> s;)
            res.push_back(s);
        return res;
    }

如果 `collect()` 耗光了内存，程序就会崩溃。
除非这个程序特别精心编写成不会耗尽内存，否则这可能正是正确的方式；
`terminate()` 能够产生合适的错误日志信息（但当内存耗尽时是很难做出任何巧妙的事情的）。

##### 注解

当你想决定是否要给函数标上 `noexcept` 时，一定要特别
注意你的代码的执行环境，尤其是与抛出异常和内存分配
相关的情形。打算成为完全通用的代码（比如像
标准库和其他类似的工具代码），应当支持那些
有意义地处理了 `bad_alloc` 异常的执行环境。
不过，大多数程序和执行环境都不能有意义地
处理内存分配失败，而中止程序则是在这些情况中
应对分类失败的最干净和最简单的方式。如果已知
应用程序代码无法应对分配失败的话，对于即使
确实会进行分配的函数，添加 `noexcept` 也是适当的。

换一种方式来说：在大多数程序中，大多数函数都会抛出异常（比如说，
它们可能使用 `new`，调用会抛出异常的函数，或者使用通过抛出异常
来报告失败的库函数），因此请勿随意到处散布 `noexcept` 而不
考虑清楚是否有异常是可以被处理的。

`noexcept` 对于常用的，底层的函数是最有用处的（并且几乎
显然是正确的）。

##### 注解

析构函数，`swap` 函数，移动操作，以及默认构造函数不应当抛出异常。

##### 强制实施

* 标记不是 `noexcept`，而又不能抛出异常的函数。
* 标记抛出异常的 `swap`，`move`，析构函数，以及默认构造函数。

### <a name="Rf-smart"></a>F.7: 对于常规用法，应当接受 `T*` 或 `T&` 参数而不是智能指针

##### 理由

智能指针的传递会转移或者共享所有权，因此应当仅在有意要实现所有权语义时才能使用（参见 [R.30](#Rr-smartptrparam)）。
使用按智能指针传递方式把函数限制为只能服务于使用智能指针的调用方。
智能指针的传递（比如 `std::shared_ptr`）暗含了一些运行时成本。

##### 示例

    void f(int*);             // 接受任何的 int*
    void g(unique_ptr<int>);  // 只能接受你想转移所有权的 int
    void g(shared_ptr<int>);  // 只能接受你想共享所有权的 int

    void h(const unique_ptr<int>&);  // 不会改变所有权，但要求调用方对其具有特定的所有权。
    
    void h(int&);             // 接受任何的 int

##### 示例，不好

    // 被调用方
    void f(shared_ptr<widget>& w)
    {
        // ...
        use(*w); // w 的唯一使用点 -- 其生存期是完全未被涉及到的
        // ...
    };

进一步请参见 [R.30](#Rr-smartptrparam)。

##### 注解

悬挂指针是可以静态地找出来的，因此我们并不需要依靠资源管理功能来避免悬挂指针。

**参见**: [何时应当采用 `T*`，何时应当采用 `T&`](#Rf-ptr-ref)。

**参见**: [智能指针的使用](#Rr-summary-smartptrs)的相关讨论。

##### 强制实施

* 标记以下情况：智能指针类型（重载了 `operator->` 或 `operator*` 的类型）的参数，它是可复制的，但从没有被从函数体中复制/移动出来，或者它是可移动，但从没有被从函数体中移动出来，或者它被按值传递，但从未进行修改或者传递给进行修改的其他函数。这意味着其中并未使用所有权语义。

### <a name="Rf-pure"></a>F.8: 优先采用纯函数

##### 理由

纯函数更容易进行推导，有时候也更易于优化（甚至并行化），有时候还可以进行存储。

##### 示例

    template<class T>
    auto square(T t) { return t * t; }

##### 注解

`constexpr` 函数就是纯函数。

##### 强制实施

不可能进行强制实施。

## <a name="SS-call"></a>F.call: 参数传递

存在各种不同的向函数传递参数和返回值的方式。


### <a name="Rf-conventional"></a>F.15: 优先采用简单的和传统的信息传递方式

##### 理由

使用“与众不同和精巧”的技巧会带来意外，其他程序员的理解减慢，并促进 BUG 的发生。
如果你确实想要比常规技巧更好的优化，请进行测量以确保它真的有所提升，并为其写下文档/注释，因为这种提升可能无法移植。

下面的表格总结了以下 F.16-21 的各个指导方针中的建议。

![一般性参数传递表](./param-passing-normal.png "一般性参数传递")

![高级参数传递表](./param-passing-advanced.png "高级参数传递")



### <a name="Rf-in"></a>F.16: 对于“输入（in）”参数，把复制操作廉价的类型按值进行传递，把其他类型按 `const` 引用进行传递

##### 理由

既能让调用者了解函数不会修改其参数，也使得参数能够以右值初始化。

何谓“复制操作廉价”依赖于机器的架构，不过只有两三个机器字（Word）的类型（double，指针，引用等）一般最好按值传递。
当可以廉价复制时，没什么比得过进行复制的简单性和安全性，而且对于小型对象（最多两三个机器字）来说，也比按引用传递更快，因为它不需要在函数中进行一次额外的引用访问。

##### 示例

    void fct(const string& s);  // OK: 按 const 引用传递; 总是廉价的

    void fct2(string s);        // bad: 可能是昂贵的

    void fct(int x);          // OK: 无可比拟

    void fct2(const int& x);  // bad: fct2() 中的访问带来开销

（仅）对于高级的运用，如果你确实需要为“只当作输入”的参数的按右值传递进行优化的话：

* 如果函数需要无条件地从参数进行移动，那就按 `&&` 来接受参数。参见 [F.18](#Rf-consume)。
* 如果函数需要保留参数的一个副本，那就在按 `const&` 接受参数（对于左值）之外，
添加一个按 `&&` 传递参数（对于右值）的重载，并在函数体中将之 `std::move` 到其目标之中。基本上，这个重载是“消耗”者；参见 [F.18](#Rf-consume)。
* 在特殊情况中，比如有多个“输入+复制”的参数时，考虑采用完美转发。参见 [F.19](#Rf-forward)。

##### 示例

    int multiply(int, int); // 仅输入了 int，按值传递

    string& concatenate(string&, const string& suffix); // suffix 仅作输入，但并不如 int 那样廉价，因此按 const& 传递

    void sink(unique_ptr<widget>);  // 仅作输入，但消耗了这个 widget

避免以下这类的“玄奥技巧”：

* “为了效率”而按 `T&&` 来传递参数。
关于按 `&&` 传递带来性能好处的大多数传言都是假的或者是脆弱的（不过也请参考 [F.25](#Rf-pass-ref-move)）。
* 从赋值或相似的操作中返回 `const T&`（参见 [F.47](#Rf-assignment-op)）。

##### 示例

假设 `Matrix` 带有移动操作（可能它将其元素都保存在一个 `std::vector` 中）：

    Matrix operator+(const Matrix& a, const Matrix& b)
    {
        Matrix res;
        // ... 用二者的和填充 res ...
        return res;
    }

    Matrix x = m1 + m2;  // 移动构造函数

    y = m3 + m3;         // 移动赋值

##### 注解

返回值优化无法处理赋值的情况，不过移动赋值却可以。

引用是被假定为指代某个有效对象的（语言规则）。
“空引用”（正规地说）是不存在的。
如果要表示一个非强制的值，请使用指针，`std::optional`，或者一个用以代表“没有值”的特殊值。

##### 强制实施
* 【简单】〔基础〕 当按值传递的参数的大小大于 `4 * sizeof(int)` 时给出警告。
  建议代之以指向 `const` 的引用。
* 【简单】〔基础〕 当按引用传递的 `const` 参数的大小小于 `3 * sizeof(int)` 时给出警告。建议代之以按值传递。
* 【简单】〔基础〕 当按引用传递的 `const` 参数被 `move` 时给出警告。


### <a name="Rf-inout"></a>F.17: 对于“输入/输出（in-out）”参数，按非 `const` 引用进行传递

##### 理由

让调用者明了这个对象假定将会被改动。

##### 示例

    void update(Record& r);  // 假定 update 将会写入 r

##### 注解

`T&` 参数既可以向函数中传递信息，也可以传递出来。
因此 `T&` 能够作为“输入/输出”参数。这点本身就可能是一种错误的来源：

    void f(string& s)
    {
        s = "New York";  // 不明显的错误
    }

    void g()
    {
        string buffer = ".................................";
        f(buffer);
        // ...
    }

这里，`g()` 的作者提供了一个缓冲区让 `f()` 来填充，但 `f()` 仅仅替换掉了它（以多少比简单的字符复制高一些的成本）。
如果 `g()` 的作者对 `buffer` 的大小作出了假设，那么就会发生糟糕的逻辑错误。

##### 强制实施
* 【中等】〔基础〕 对带有指向非 `const` 的引用参数但又*不*向其进行写入的函数给出警告。
* 【简单】〔基础〕 当按引用传递的非 `const` 参数被进行 `move` 时给出引用。







